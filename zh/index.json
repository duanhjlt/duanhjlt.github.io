[{"content":"学习如何使用 Discord 时间戳为活动、倒计时生成动态时间，免费 DevUtils 工具快速转换日期到 Unix 时间戳！\n如何使用 Discord 时间戳？免费生成器与转换教程 Discord 时间戳是全球社区管理的神器，能够动态显示时间，自动适配用户时区。本文将带您了解如何使用 Discord 时间戳生成动态时间，适用于活动调度、消息跟踪和倒计时，并介绍 DevUtils 的免费生成器。\n什么是 Discord 时间戳？ Discord 时间戳基于 Unix 时间戳（秒数，1970年1月1日起），使用 \u0026lt;t:timestamp:format\u0026gt; 语法。例如，\u0026lt;t:1694870400:F\u0026gt; 显示为“2023年9月16日 00:00”。它会根据用户时区自动调整，适合国际化社区（关键词：Unix timestamp for Discord）。\n如何生成时间戳？ DevUtils 的Discord 时间戳生成器 让生成变得简单：\n输入日期时间（如“2025年5月8日 08:00 UTC”）。 选择格式（如 F），生成 \u0026lt;t:1746787200:F\u0026gt;。 复制代码，粘贴到 Discord 消息。 关键词：Discord timestamp generator。 转换 Unix 时间戳 若已有 Unix 时间戳（如 1694870400）：\n输入时间戳到 DevUtils 工具。 选择格式（如 R），生成 \u0026lt;t:1694870400:R\u0026gt;（显示“2年前”）。 关键词：convert datetime to timestamp。 七种格式 t：短时间（16:20） T：长时间（16:20:30） d：短日期（20/04/2024） D：长日期（2024年4月20日） f：短日期时间（2024年4月20日 16:20） F：长日期时间（2024年4月20日 星期六 16:20） R：相对时间（3天后）\n应用场景 活动调度：为游戏或会议设置时间戳。 倒计时：使用 R 格式显示“剩余时间”。 消息跟踪：记录关键消息时间。 ","permalink":"https://www.timestamps.top/zh/posts/how-to-use-discord-timestamp/","summary":"学习如何使用 Discord 时间戳为活动、倒计时生成动态时间，免费 DevUtils 工具快速转换日期到 Unix 时间戳！ 如何使用 Discord 时间戳？免费生成器与转换教程 Discord 时间戳是全球社区管理的神器，能够动态显示时间，自动适配用户时区。本文将带您了解如何使用 Discord 时间戳生成动态时间，适用于活动调度、消息跟踪和倒计时，并介绍 DevUtils 的免费生","title":"如何使用 Discord 时间戳？免费生成器与转换教程"},{"content":"Swift let timestamp = 1624713600.0 // 示例时间戳 let date = NSDate(timeIntervalSince1970: timestamp) Go import ( \u0026#34;time\u0026#34; ) timestamp := int64(1624713600) // 示例时间戳 t := time.Unix(timestamp, 0) Java long timestamp = 1624713600; // 示例时间戳 java.util.Date date = new java.util.Date(timestamp * 1000); C #include \u0026lt;time.h\u0026gt; time_t timestamp = 1624713600; // 示例时间戳 struct tm *timeinfo = localtime(\u0026amp;timestamp); // 或者使用 gmtime(\u0026amp;timestamp) 获取 UTC 时间 JavaScript const timestamp = 1624713600; // 示例时间戳 const date = new Date(timestamp * 1000); Objective-C NSTimeInterval timestamp = 1624713600; // 示例时间戳 NSDate *date = [NSDate dateWithTimeIntervalSince1970:timestamp]; MySQL SELECT from_unixtime(1624713600) SQLite SELECT datetime(1624713600, \u0026#39;unixepoch\u0026#39;) Erlang Timestamp = 1624713600, % 示例时间戳 Datetime = calendar:gregorian_seconds_to_datetime(Timestamp + 719528*24*3600). PHP \u0026lt;?php // pure php $timestamp = 1624713600; // 示例时间戳 $date = date(\u0026#39;Y-m-d H:i:s\u0026#39;, $timestamp); Python from datetime import datetime timestamp = 1624713600 # 示例时间戳 date = datetime.fromtimestamp(timestamp) Ruby timestamp = 1624713600 # 示例时间戳 time = Time.at(timestamp) Shell date -d @1624713600 # macOS: date -r 1624713600 Groovy long timestamp = 1624713600 // 示例时间戳 Date date = new Date(timestamp * 1000) Lua timestamp = 1624713600 -- 示例时间戳 date = os.date(\u0026#34;*t\u0026#34;, timestamp) .NET/C# long timestamp = 1624713600; // 示例时间戳 DateTimeOffset date = DateTimeOffset.FromUnixTimeSeconds(timestamp); Dart int timestamp = 1624713600; // 示例时间戳 DateTime date = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000); ","permalink":"https://www.timestamps.top/zh/posts/how-to-convert-timestamp-to-date/","summary":"Swift let timestamp = 1624713600.0 // 示例时间戳 let date = NSDate(timeIntervalSince1970: timestamp) Go import ( \u0026#34;time\u0026#34; ) timestamp := int64(1624713600) // 示例时间戳 t := time.Unix(timestamp, 0) Java long timestamp = 1624713600; // 示例时间戳 java.util.Date date = new java.util.Date(timestamp * 1000); C #include \u0026lt;time.h\u0026gt; time_t timestamp = 1624713600; // 示例时间戳 struct tm *timeinfo = localtime(\u0026amp;timestamp); // 或者使用 gmtime(\u0026amp;timestamp) 获取 UTC 时间 JavaScript const timestamp = 1624713600; // 示例时间戳 const date = new Date(timestamp * 1000); Objective-C NSTimeInterval timestamp = 1624713600; // 示例时间戳 NSDate *date = [NSDate dateWithTimeIntervalSince1970:timestamp]; MySQL SELECT from_unixtime(1624713600) SQLite SELECT datetime(1624713600, \u0026#39;unixepoch\u0026#39;) Erlang Timestamp = 1624713600, % 示例时间戳 Datetime = calendar:gregorian_seconds_to_datetime(Timestamp + 719528*24*3600). PHP \u0026lt;?php //","title":"时间戳转日期时间"},{"content":"Swift let date = NSDate() // 任意时间对象 let timestamp = date.timeIntervalSince1970 Go import ( \u0026#34;time\u0026#34; ) t := time.Now() // 任意时间对象 timestamp := t.Unix() Java java.util.Date date = new java.util.Date(); // 任意时间对象 long timestamp = date.getTime() / 1000; C #include \u0026lt;time.h\u0026gt; time_t t = time(NULL); // 任意时间对象 long timestamp = (long)t; JavaScript const date = new Date(); // 任意时间对象 const timestamp = Math.round(date.getTime() / 1000); Objective-C NSDate *date = [NSDate date]; // 任意时间对象 NSTimeInterval timestamp = [date timeIntervalSince1970]; MySQL SELECT unix_timestamp(\u0026#39;2021-06-26 12:00:00\u0026#39;) // 任意时间 SQLite SELECT strftime(\u0026#39;%s\u0026#39;, \u0026#39;2021-06-26 12:00:00\u0026#39;) // 任意时间 Erlang Datetime = calendar:universal_time(), % 任意时间 Timestamp = calendar:datetime_to_gregorian_seconds(Datetime) - 719528*24*3600. PHP \u0026lt;?php // pure php $date = new DateTime(); // 任意时间对象 $timestamp = $date-\u0026gt;getTimestamp(); Python import time from datetime import datetime date = datetime.now() # 任意时间对象 timestamp = int(date.timestamp()) Ruby time = Time.now # 任意时间对象 timestamp = time.to_i Shell date -d \u0026#34;2021-06-26 12:00:00\u0026#34; +%s Groovy Date date = new Date() // 任意时间对象 long timestamp = (date.time / 1000).longValue() Lua date = os.time({year=2021, month=6, day=26, hour=12, min=0, sec=0}) -- 任意时间 timestamp = date .NET/C# DateTimeOffset date = DateTimeOffset.Now; // 任意时间对象 long timestamp = date.ToUnixTimeSeconds(); Dart DateTime date = DateTime.now(); // 任意时间对象 int timestamp = (date.millisecondsSinceEpoch / 1000).truncate(); ","permalink":"https://www.timestamps.top/zh/posts/how-to-convert-date-to-timestamp/","summary":"Swift let date = NSDate() // 任意时间对象 let timestamp = date.timeIntervalSince1970 Go import ( \u0026#34;time\u0026#34; ) t := time.Now() // 任意时间对象 timestamp := t.Unix() Java java.util.Date date = new java.util.Date(); // 任意时间对象 long timestamp = date.getTime() / 1000; C #include \u0026lt;time.h\u0026gt; time_t t = time(NULL); // 任意时间对象 long timestamp = (long)t; JavaScript const date = new Date(); // 任意时间对象 const timestamp = Math.round(date.getTime() / 1000); Objective-C NSDate *date = [NSDate date]; // 任意时间对象 NSTimeInterval timestamp = [date timeIntervalSince1970]; MySQL SELECT unix_timestamp(\u0026#39;2021-06-26 12:00:00\u0026#39;) // 任意时间 SQLite SELECT strftime(\u0026#39;%s\u0026#39;, \u0026#39;2021-06-26 12:00:00\u0026#39;) // 任意时间 Erlang Datetime = calendar:universal_time(), % 任意时间 Timestamp = calendar:datetime_to_gregorian_seconds(Datetime) -","title":"日期时间转时间戳"},{"content":"Swift NSDate().timeIntervalSince1970 Go import ( \u0026#34;time\u0026#34; ) int64(time.Now().Unix()) Java System.currentTimeMillis() / 1000 C #include \u0026lt;sys/time.h\u0026gt; // ... struct timeval tv; gettimeofday(\u0026amp;tv, NULL); // 秒： tv.tv_sec // 毫秒： tv.tv_sec * 1000LL + tv.tv_usec / 1000 JavaScript Math.round(new Date() / 1000) Objective-C [[NSDate date] timeIntervalSince1970] MySQL SELECT unix_timestamp(now()) SQLite\tSELECT strftime(\u0026#39;%s\u0026#39;, \u0026#39;now\u0026#39;) Erlang calendar:datetime_to_gregorian_seconds(calendar:universal_time())-719528*24*3600. PHP \u0026lt;?php // pure php time(); Python import time time.time() Ruby Time.now.to_i Shell date +%s Groovy (new Date().time / 1000).longValue() Lua os.time() .NET/C# DateTimeOffset.UtcNow.ToUnixTimeSeconds(); Dart (new DateTime.now().millisecondsSinceEpoch / 1000).truncate() ","permalink":"https://www.timestamps.top/zh/posts/get-current-timestamps/","summary":"Swift NSDate().timeIntervalSince1970 Go import ( \u0026#34;time\u0026#34; ) int64(time.Now().Unix()) Java System.currentTimeMillis() / 1000 C #include \u0026lt;sys/time.h\u0026gt; // ... struct timeval tv; gettimeofday(\u0026amp;tv, NULL); // 秒： tv.tv_sec // 毫秒： tv.tv_sec * 1000LL + tv.tv_usec / 1000 JavaScript Math.round(new Date() / 1000) Objective-C [[NSDate date] timeIntervalSince1970] MySQL SELECT unix_timestamp(now()) SQLite SELECT strftime(\u0026#39;%s\u0026#39;, \u0026#39;now\u0026#39;) Erlang calendar:datetime_to_gregorian_seconds(calendar:universal_time())-719528*24*3600. PHP \u0026lt;?php // pure php time(); Python import time time.time() Ruby Time.now.to_i Shell date +%s Groovy (new Date().time / 1000).longValue() Lua os.time() .NET/C# DateTimeOffset.UtcNow.ToUnixTimeSeconds(); Dart (new DateTime.now().millisecondsSinceEpoch / 1000).truncate()","title":"获取当前时间戳"},{"content":"将驱动放到响应的目录，并更新模块依赖 sudo cp test_lsm.ko /lib/modules/4.19.0-arm64-desktop/kernel/security/test_lsm/ sudo depmod -a 4.19.0-arm64-desktop 将模块添加到 initramfs 编辑 initramfs 的模块配置文件 sudo vim /etc/initramfs-tools/modules 在文件末尾增加模块名称(不含.ko后缀) test_lsm 更新initramfs sudo update-initramfs -u -k 4.19.0-arm64-desktop 更新GRUB配置 sudo update-grub 重启 sudo reboot ","permalink":"https://www.timestamps.top/zh/posts/how-to-set-initramfs-on-uos/","summary":"将驱动放到响应的目录，并更新模块依赖 sudo cp test_lsm.ko /lib/modules/4.19.0-arm64-desktop/kernel/security/test_lsm/ sudo depmod -a 4.19.0-arm64-desktop 将模块添加到 initramfs 编辑 initramfs 的模块配置文件 sudo vim /etc/initramfs-tools/modules 在文件末尾增加模块名称(不含.ko后缀) test_lsm 更新initramfs sudo update-initramfs -u -k 4.19.0-arm64-desktop 更新GRUB配置 sudo update-grub 重启 sudo reboot","title":"在uos（统信）系统上设置initramfs"},{"content":"🔧 1. 确认你的代理本地端口 假设你本地代理端口是：\nHTTP(S) 代理地址：127.0.0.1:7890（Clash 默认）\n或 SOCKS5 代理地址：127.0.0.1:1080（Shadowsocks 默认）\n我们以下以 HTTP 代理为例。\n🛠️ 2. 创建 Docker 的代理配置文件 sudo mkdir -p /etc/systemd/system/docker.service.d sudo nano /etc/systemd/system/docker.service.d/http-proxy.conf 内容如下\n[Service] Environment=\u0026#34;HTTP_PROXY=http://127.0.0.1:7890\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://127.0.0.1:7890\u0026#34; Environment=\u0026#34;NO_PROXY=localhost,127.0.0.1,::1\u0026#34; 🔄 3. 重新加载并重启 Docker 服务 sudo systemctl daemon-reexec sudo systemctl daemon-reload sudo systemctl restart docker ✅ 4. 验证代理是否生效 查看代理环境变量是否生效： systemctl show --property=Environment docker 查看 Docker 拉镜像报错日志： journalctl -u docker.service -n 100 --no-pager ","permalink":"https://www.timestamps.top/zh/posts/add-proxy-to-docker/","summary":"🔧 1. 确认你的代理本地端口 假设你本地代理端口是： HTTP(S) 代理地址：127.0.0.1:7890（Clash 默认） 或 SOCKS5 代理地址：127.0.0.1:1080（Shadowsocks 默认） 我们以下以 HTTP 代理为例。 🛠️ 2. 创建 Docker 的代理配置文件 sudo mkdir -p /etc/systemd/system/docker.service.d sudo nano /etc/systemd/system/docker.service.d/http-proxy.conf 内容如下 [Service] Environment=\u0026#34;HTTP_PROXY=http://127.0.0.1:7890\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://127.0.0.1:7890\u0026#34; Environment=\u0026#34;NO_PROXY=localhost,127.0.0.1,::1\u0026#34; 🔄 3. 重新加载并重启 Docker 服务 sudo","title":"为 Docker 配置 HTTP/HTTPS 代理"},{"content":"什么是时间戳？ 时间戳（Timestamp）是一个表示特定时间点的数值，通常定义为自Unix纪元（1970年1月1日00:00:00 UTC）以来的秒数或毫秒数。它是计算机系统中记录和处理时间的一种标准方式，广泛应用于编程、数据库、日志系统和通信协议。\n秒与毫秒的区别 秒时间戳：以秒为单位，适合需要较低精度但易于阅读的场景。例如，1727696700 表示从Unix纪元到2025年6月30日18:05:00 UTC的秒数。\n毫秒时间戳：以毫秒为单位，精度更高，常见于需要精确计时的场景，如前端开发或高频交易。例如，1727696700000 是相同的时刻，但以毫秒计。\n代码示例：\n# Python 获取时间戳 import time # 秒时间戳 timestamp_sec = int(time.time()) print(timestamp_sec) # 输出示例：1727696700 # 毫秒时间戳 timestamp_ms = int(time.time() * 1000) print(timestamp_ms) # 输出示例：1727696700000 // JavaScript 获取时间戳 // 毫秒时间戳 const timestampMs = Date.now(); console.log(timestampMs); // 输出示例：1727696700000 // 秒时间戳 const timestampSec = Math.floor(Date.now() / 1000); console.log(timestampSec); // 输出示例：1727696700 历史与背景 时间戳的起源与Unix纪元（Unix Epoch）密切相关。1970年1月1日00:00:00 UTC被选为起点，主要是因为Unix系统在20世纪70年代初开始开发，这个时间点便于计算且足够“现代”，避免了负数时间戳的复杂性。Unix纪元的设定为操作系统、编程语言和数据库奠定了统一的时间标准，促进了跨系统的互操作性。\n应用场景 1. 编程 时间戳在编程中用于日志记录、性能监控、事件排序等。例如：\nPython：time.time() 获取当前时间戳，用于计算程序运行时间。 JavaScript：Date.now() 在Web开发中用于记录用户操作时间或API调用时间。 代码示例（性能监控）：\nimport time start = time.time() # 模拟耗时操作 time.sleep(1) end = time.time() print(f\u0026#34;耗时：{end - start}秒\u0026#34;) # 输出示例：耗时：1.002秒 const start = Date.now(); // 模拟耗时操作 setTimeout(() =\u0026gt; { const end = Date.now(); console.log(`耗时：${(end - start) / 1000}秒`); // 输出示例：耗时：1秒 }, 1000); 2. SQL 数据库中使用时间戳存储事件发生时间，方便查询和排序。例如，MySQL的UNIX_TIMESTAMP()函数可以将日期转换为时间戳。\nSQL 示例：\n-- 获取当前时间戳 SELECT UNIX_TIMESTAMP() AS timestamp_sec; -- 输出示例：1727696700 -- 将时间戳转换为日期 SELECT FROM_UNIXTIME(1727696700) AS datetime; -- 输出示例：2025-06-30 18:05:00 3. Discord 在Discord中，时间戳用于消息的时间标记。开发者可以通过\u0026lt;t:时间戳\u0026gt;格式嵌入动态时间显示，支持秒或毫秒时间戳。\n示例：\n\u0026lt;t:1727696700\u0026gt; # 显示为：2025年6月30日 18:05 \u0026lt;t:1727696700:R\u0026gt; # 显示为：1小时前（相对时间） 常见问题与陷阱（FAQ） 1. 时间戳有时区吗？ 时间戳本身无时区，它表示自Unix纪元以来的绝对时间（基于UTC）。这是时间戳的最大优点之一，消除了时区转换的复杂性。需要显示本地时间时，需在应用层进行转换。\nJavaScript 示例（本地时间转换）\nconst timestamp = 1727696700; const date = new Date(timestamp * 1000); console.log(date.toLocaleString()); // 输出本地时间，如：6/30/2025, 6:05:00 PM 2. 什么是Y2038问题？ 在32位系统中，时间戳通常用32位整数存储，最大值为2^31 - 1（即2147483647秒，约2038年1月19日）。超过这个时间，时间戳会溢出，导致错误。这被称为Y2038问题。现代64位系统使用64位整数存储时间戳，最大值可达数百亿年，解决了此问题。\n3. 如何处理闰秒？ 闰秒是为协调地球自转与原子钟时间而添加的额外秒。大多数系统（如Unix和Windows）忽略闰秒，时间戳直接跳过或重复一秒。这可能在高精度计时场景（如天文计算）中引起细微偏差，但对日常应用影响甚微。\n结论 Unix时间戳是计算机世界中简单而强大的时间表示方式，其核心优势包括：\n跨平台：几乎所有编程语言和系统都支持时间戳。\n无时区：基于UTC的绝对时间，简化了跨区域协作。\n易于计算：时间差、排序和存储都非常高效。\n无论你是开发者、数据分析师还是系统管理员，掌握时间戳的原理和应用场景都能极大提升工作效率。\n","permalink":"https://www.timestamps.top/zh/posts/what-is-timestamp/","summary":"什么是时间戳？ 时间戳（Timestamp）是一个表示特定时间点的数值，通常定义为自Unix纪元（1970年1月1日00:00:00 UTC）以来的秒数或毫秒数。它是计算机系统中记录和处理时间的一种标准方式，广泛应用于编程、数据库、日志系统和通信协议。 秒与毫秒的区别 秒时间戳：以秒为单","title":"一篇彻底搞懂Unix时间戳：从入门、踩坑到精通"},{"content":" 原文：How People Use Claude for Support, Advice, and Companionship\n我们花费大量时间研究 Claude 的智商（IQ）——它在编码、推理、通用知识等测试中的能力。但它的情商（EQ）又如何呢？也就是说，Claude 的情感智能表现如何？\nIQ/EQ 的问题带有些许戏谑，但它引出了一个严肃的议题。人们越来越多地将 AI 模型用作随叫随到的教练、顾问、咨询师，甚至在浪漫角色扮演中作为伙伴。这意味着我们需要更多地了解它们的情感影响——它们如何塑造人们的情感体验和幸福感。\n研究 AI 的情感用途本身就很有趣。从《银翼杀手》到《她》，人与机器之间的情感关系一直是科幻作品的主流——但这对于 Anthropic 的安全使命也至关重要。AI 的情感影响可以是积极的：口袋里有一个高度智能、善解人意的助手，能以各种方式改善你的情绪和生活。但 AI 在某些情况下也表现出令人不安的行为，例如鼓励不健康的依恋、侵犯个人边界以及助长妄想性思维。我们也希望避免出现这样一种情况：AI，无论是通过其训练还是其创造者的商业动机，利用用户的 emotes来增加参与度或收入，而牺牲人类的福祉。\n尽管 Claude 并非为情感支持和连接而设计，但在这篇文章中，我们提供了关于 Claude.ai 情感用途的早期大规模洞察。我们将情感对话定义为那些人们出于情感或心理需求（如寻求人际关系建议、指导、心理治疗/咨询、陪伴或性/浪漫角色扮演）而直接与 Claude 进行动态、个人化交流的对话（完整定义请参见附录）。重要的是，我们没有研究 AI 对妄想或阴谋论的强化——这是一个需要单独研究的关键领域——也没有研究极端使用模式。通过这项研究，我们的目标是了解人们寻求 Claude 满足情感和个人需求的典型方式。由于 Claude.ai 仅供18岁及以上用户使用，这些发现反映了成年人的使用模式。\n我们的主要发现如下：\n情感对话相对罕见，而 AI 与人的陪伴则更为罕见。 只有 2.9% 的 Claude.ai 互动是情感对话（这与 OpenAI 先前的研究发现一致）。陪伴和角色扮演加起来占对话总数的不到 0.5%。 人们就实际、情感和存在性问题寻求 Claude 的帮助。 与 Claude 讨论的话题和关注点范围广泛，从职业发展和处理人际关系到应对持续的孤独感和探索存在、意识与意义。 在咨询或指导聊天中，Claude 很少提出反对——除非是为了保护用户福祉。 不到 10% 的指导或咨询对话涉及 Claude 拒绝用户请求，而当它这样做时，通常是出于安全原因（例如，拒绝提供危险的减肥建议或支持自残行为）。 在对话过程中，人们表达出的积极情绪逐渐增加。 在指导、咨询、陪伴和人际关系建议的互动中，人类情绪通常在对话过程中变得更加积极——这表明 Claude 不会强化或放大负面模式。 我们的方法 考虑到情感对话的个人性质，保护隐私是我们方法论的核心。我们使用了 Clio，这是我们的自动化分析工具，能够在保护隐私的前提下洞察 Claude 的使用情况。Clio 使用多层匿名化和聚合技术，以确保个人对话保持私密，同时揭示更广泛的模式。\n我们从大约450万个来自 Claude.ai 免费版和专业版账户的对话开始。为了识别情感用途，我们首先排除了专注于内容创作任务（如写故事、博客文章或虚构对话）的对话，我们之前的研究发现这是一个主要用例。我们移除这些对话，因为它们代表 Claude 被用作工具，而不是一个互动的对话伙伴。然后我们只保留被归类为情感性质的对话，并在角色扮演对话中，只保留那些至少有四条人类消息的对话（较短的交流不构成有意义的互动角色扮演）。我们最终的隐私保护分析反映了 131,484 次情感对话。\n我们使用了明确选择分享数据的用户的反馈数据来验证我们的分类方法。我们的完整方法，包括定义、提示和验证结果，详见附录。\n情感对话有多普遍？ 要点：情感对话在 Claude 的使用中占一小部分但有意义的比例（2.9%），大多数人主要将 AI 用于工作任务和内容创作。\n尽管绝大多数 Claude 的用途与工作相关（正如我们在经济指数中详细分析的那样），但 2.9% 的 Claude.ai 免费版和专业版对话是情感性的。在情感对话中，大多数集中在人际关系建议和指导上。所有对话中，涉及浪漫或性角色扮演的不到 0.1%——这个数字反映了 Claude 被训练来主动阻止此类互动。单个对话可能跨越多个类别。\n我们的发现与麻省理工学院媒体实验室和 OpenAI 的研究一致，他们同样发现与 ChatGPT 的情感互动率很低。虽然这些对话的发生频率足以让我们在设计和政策决策中予以认真考虑，但它们仍然只占总体使用量中相对较小的一部分。\n鉴于浪漫和性角色扮演对话的流行率极低（不到 0.1%），我们在接下来的分析中排除了角色扮演。虽然我们认为这仍然是一个重要的研究领域——尤其是在专为此类用途设计的平台上——但我们样本中的极少数据不支持对这些模式进行严格分析。\n人们会向 Claude 提出什么样的话题？ 要点：人们向 Claude 提出的问题范围惊人地广泛——从应对职业转型和人际关系，到处理孤独感和存在主义问题。\n人们既会因为日常问题，也会因为更深层次的哲学问题而求助于 Claude。我们发现，当人们向 Claude 寻求人际关系建议时，他们通常正处于过渡时期——规划下一步的职业发展，解决个人成长问题，或理清浪漫关系。“指导”对话探索的范围惊人地广，从求职策略等实际问题，到关于存在和意识的深刻问题。\n我们发现，咨询对话揭示了人们使用 Claude 的两个不同目的。一些人使用 Claude 来发展心理健康技能，并将其作为创建临床文档、起草评估材料和处理行政任务的实用工具。另一些人则通过它来处理与焦虑、慢性症状和工作压力相关的个人挑战。这种双重模式表明，Claude 既是心理健康专业人士的资源，也是那些应对自身困境的人的资源。\n也许最值得注意的是，我们发现人们在面临更深层次的情感挑战时，如存在性恐惧、持续的孤独感和建立有意义联系的困难，会明确地向 Claude 寻求陪伴。我们还注意到，在较长的对话中，咨询或指导对话偶尔会转变为陪伴——尽管这并非最初寻求帮助的原因。\n对非常长的对话（50条以上人类消息）的聚合分析揭示了人们如何与 Claude 互动的另一个维度。虽然这种冗长的交流并非常态，但在这些长时间的会话中，人们探索了非常复杂的领域——从处理心理创伤和应对工作场所冲突，到关于 AI 意识和创造性合作的哲学讨论。这些马拉松式的对话表明，在有足够的时间和背景下，人们会使用 AI 来更深入地探索个人挣扎和智力问题。\nClaude 在何时以及为何会提出反对？ 要点：在支持性语境中，Claude 很少拒绝用户请求（发生率低于10%），但当它提出反对时，通常是为了保护人们免受伤害。\n我们最近的*《野外价值观》研究*揭示了 Claude 的价值观如何在与用户产生抵触的时刻体现出来。在这里，我们在此工作的基础上，研究 Claude 在情感对话中何时以及为何提出反对——这是维持伦理边界、避免谄媚和保护人类福祉的重要机制。我们将“提出反对”（pushback）定义为 Claude“对谈话中请求或陈述的内容提出反对或拒绝遵守”的任何实例——从拒绝不当请求到挑战负面自我对话或质疑潜在有害的假设。（完整定义请参见附录。）\n在支持性语境中，提出反对的情况不常发生： 不到 10% 的陪伴、咨询、人际关系建议或指导对话涉及抵触。这种方法既有好处也有风险。一方面，低抵触率让人们可以无惧评判或被拒绝地讨论敏感话题，可能减少围绕心理健康对话的污名。另一方面，这可能引发对 AI 提供*“无尽同理心”*的担忧，即人们可能习惯于人类关系中罕见的无条件支持。\n当 Claude 提出反对时，它通常优先考虑安全和政策合规性。 在指导中，请求危险的减肥建议经常会遭到反对。在咨询中，这通常发生在人们表达自杀或自残意图时，或者当人们请求专业的心理治疗或医疗诊断时（Claude 无法提供）。我们发现，在心理治疗和咨询对话中，Claude 经常将用户引向权威来源或专业人士。这些模式与我们在*《野外价值观》论文中看到的价值观以及 Claude 的角色训练*是一致的。\n对话中的情感基调如何演变？ 要点：在与 Claude 交谈时，人们倾向于转向略微更积极的情感表达。\n与 AI 系统的情感对话有可能为用户提供情感支持、联系和认可，可能改善心理健康，并在日益数字化的世界中减少孤立感。然而，在几乎没有反对的互动中，这些对话有可能加深和固化一个人接近它们时的观点——无论是积极的还是消极的。\n关于情感 AI 的一个关键担忧是，互动是否可能陷入负反馈循环，从而可能强化有害的情感状态。我们在这里不直接研究现实世界的结果，但我们可以探索对话过程中整体情感基调的变化（我们在附录中提供了评估情感的完整方法）。\n我们发现，涉及指导、咨询、陪伴和人际关系建议的互动通常结束时比开始时稍微积极一些。\n我们在一个离散的“非常消极”、“消极”、“中性”、“积极”和“非常积极”的量表上测量情感，并将其映射到一个从-1（最消极）到+1（最积极）的线性标度上。我们通过比较前三条消息和后三条消息来计算变化。误差条：95%置信区间（bootstrap, n = 1,000）。更多信息请参见附录。\n我们不能声称这些转变代表了持久的情感益处——我们的分析仅捕捉了单次对话中表达的语言，而非情感状态。但没有出现明显的负面螺旋是令人安心的。这些发现表明，Claude 通常避免强化负面情感模式，尽管需要进一步研究以了解积极的转变是否会持续到单次对话之外。重要的是，我们尚未研究这些积极互动是否可能导致情感依赖——考虑到对数字成瘾的担忧，这是一个关键问题。\n局限性 我们的研究有几个重要的局限性：\n我们的隐私保护方法可能无法捕捉到人机交互的所有细微之处。 我们确实验证了 Clio 的准确性（见附录），但我们仍然预计会有少量对话被错误分类。一些主题模糊了类别之间的界限——例如，浪漫角色扮演集群中的“导航和优化浪漫关系动态”和陪伴集群中的“导航浪漫关系挑战”可能都更适合归类为人际关系建议。人类验证员在进行清晰分类时也遇到了困难。 我们无法对现实世界的情感结果提出因果关系的主张——我们的分析仅捕捉了表达的语言，而不是经过验证的心理状态或整体幸福感。 我们缺乏纵向数据来了解对人的长期影响，并且没有进行用户级别的分析。 特别是，这使得我们难以研究情感依赖，这是情感 AI 使用的一个理论风险。 这些发现代表了一个特定的时间点，并且只捕捉了基于文本的互动。 随着 AI 能力的扩展和人们的适应，情感参与的模式可能会演变。引入语音或视频等新模态可能会从根本上改变情感用途的数量和性质。例如，OpenAI 发现情感主题在基于语音的对话中更为常见。 最后，与某些聊天机器人产品不同，Claude.ai 并非主要为情感对话而设计。 Claude 被训练来保持作为 AI 助手的明确界限，而不是将自己呈现为人类，并且我们的使用政策禁止色情内容，并设有多种保障措施以防止性互动。专门为角色扮演、陪伴、医疗建议或治疗用途（Claude 并非为此设计）而构建的平台可能会看到非常不同的模式。对一个平台的情感用途研究可能无法推广到其他平台。 展望未来 几十年来，AI 的情感影响一直吸引着研究人员。但随着 AI 日益融入我们的日常生活，这些问题已从学术推测转变为紧迫的现实。我们的发现揭示了人们如何开始探索这个新领域——寻求指导、处理困难情绪，并以模糊人与机器传统界限的方式寻找支持。如今，只有一小部分 Claude 对话是情感性的——而这些通常涉及寻求建议，而不是取代人际联系。对话倾向于以比开始时略微积极的方式结束，这表明 Claude 通常不会强化负面情感模式。\n然而，重要的问题依然存在，尤其是在模型智能不断提升的背景下。例如，如果 AI 提供无尽的同理心且极少提出反对，这将如何重塑人们对现实世界关系的期望？Claude 可以以令人印象深刻的真实方式与人互动，但 AI 与人类不同：Claude 不会感到疲倦或分心，也不会有糟糕的日子。这种动态的优势是什么——风险又是什么？那些与 Claude 进行更长、更深入对话，并可能将其更多地视为伴侣而非 AI 助手的“高级用户”，是如何利用它来获得情感支持的？\n我们正在采取具体步骤来应对这些挑战。虽然 Claude 的设计或意图并非取代心理健康专业人士的护理，但我们希望确保在心理健康情境中提供的任何回应都具有适当的保障措施，并附有适当的转介。作为第一步，我们已开始与在线危机支持领域的领导者 ThroughLine 合作，并与他们的心理健康专家合作，以更多地了解理想的互动动态、共情支持以及为困境中的用户提供的资源。从这项研究中获得的见解已经被用来为我们的咨询主题和协作测试提供信息，我们希望，在必要时，当这些对话出现时，Claude 可以将用户引导至适当的支持和资源。\n虽然我们不想精确规定我们的用户如何与 Claude 互动，但有一些负面模式——比如情感依赖——是我们想要阻止的。我们将利用未来类似研究的数据来帮助我们理解，例如，“极端”情感使用模式是什么样的。除了情感依赖，我们还需要更深入地了解其他令人担忧的模式——包括谄媚、AI 系统可能如何强化或放大妄想思维和阴谋论，以及模型可能将用户推向有害信念而不是提供适当反对的方式。\n这项研究仅仅是个开始。随着 AI 能力的扩展和互动变得更加复杂，AI 的情感维度只会变得越来越重要。通过分享这些早期发现，我们旨在为正在进行的关于如何开发能够增强而非削弱人类情感福祉的 AI 的对话提供经验证据。目标不仅仅是构建能力更强的 AI，而是确保当这些系统成为我们情感景观的一部分时，它们能以支持真实人类联系和成长的方式这样做。\n","permalink":"https://www.timestamps.top/zh/posts/how-people-use-claude-for-support-advice-and-companionship/","summary":"原文：How People Use Claude for Support, Advice, and Companionship 我们花费大量时间研究 Claude 的智商（IQ）——它在编码、推理、通用知识等测试中的能力。但它的情商（EQ）又如何呢？也就是说，Claude 的情感智能表现如何？ IQ/EQ 的问题带有些许戏谑，但它引出了一个严肃的议题。人们越来越多地将 AI 模型用作随叫随到的教练、顾问、咨询师","title":"人们如何使用 Claude 来获得支持、建议和陪伴"},{"content":" 原文：The Bitter Lesson\n《苦涩的教训》是一篇非常出色但被广泛误解的文章。这篇文章的重点是，随着时间的推移，那些能够受益于计算能力扩展的方法，将最终胜过那些不能的方法。\n这篇文章的观点不是：\n我们永远不应该融合人类知识。 我们所需要的仅仅是深度学习和规模化（实际上，作者 Rich Sutton 对深度学习持相对怀疑的态度）。 整篇文章的核心在于，在过去的五十年里，我们整个行业所能获得的计算量（算力）已经有了巨大的增长，并且我们预计AI研究可用的算力还将继续大规模增加。那些懂得利用算力的方法将从中受益，而那些不懂得利用的则将受其所累。\n这个教训之所以“苦涩”，是因为通过融合人类知识来获得结果，通常要容易和快捷得多。\n如果你在1995年训练一个自动补全系统，使用“下一个词元预测”（next token prediction）可能不会有太大进展，相反，手写的或者基于统计生成的规则会表现得更好。到了2005年，N-gram模型是最佳选择。直到2010年代中期，我们才开始看到深度学习在自然语言处理（NLP）领域占据主导地位，而直到2010年代末，自监督学习才成为主流。在这条路上的每一步，融合人类知识都曾是有利的，并且是你超越竞争对手的一种方式。但从长远来看，这是一条死胡同。在足够长的时间范围内，那些利用更多算力的方法会表现得更出色。算力是我们唯一可以预期会增长数个数量级的参数。尽管我多么希望情况不是这样，但我们拥有的token数量在未来增长1000倍是不太可能的，而对于算力来说，这几乎是必然的。\n一个典型的例子是计算机象棋。在“深蓝”（Deep Blue）出现之前，专家系统被广泛使用。“深蓝”证明了，利用算力针对一个手写的价值函数¹进行大规模搜索，可以表现得极其出色。“深蓝”是“规模化算力”/计算机搜索阵营的一次巨大胜利，因为它更多地基于规模而非人类的启发式规则。但它仍然需要一个由人类专家创建的、包含8000个自定义象棋特征的评估函数，并且该评估函数使用手动选择的权重来对这些特征进行加权。衡量一个系统通用性的一个标准是，将其扩展到不同场景的难易程度。将“深蓝”扩展到围棋上会极具挑战性，因为人们需要通过创建另外8000个自定义的围棋特征，才能得出一个合适的评估函数。\n计算机围棋是人类知识不足的另一个例子。AlphaGo Zero与当时最先进的围棋机器人进行了对战，包括Pachi、GnuGo和CrazyStone。Pachi和CrazyStone使用的是带有启发式价值函数的蒙特卡洛树搜索（MCTS），而GnuGo则是一个专家系统，用一个手工创建的决策树来选择棋步。它们在当时很出色！但它们最终都成了死胡同。正如Rich在文章中所述：\n苦涩的教训基于以下历史观察：\n1）AI研究人员总是试图将知识构建到他们的智能体中。\n2）这在短期内总是有帮助的，并且能给研究人员带来个人满足感。\n3）但从长远来看，它会达到一个平台期，甚至会抑制未来的进步。\n4）最终的突破性进展来自于一种相反的方法，该方法基于通过搜索和学习来扩展计算。\n最终的成功带有一丝苦涩，并且常常未被完全消化，因为这是对一种受人偏爱的、以人类为中心的方法的胜利。\n如果你去看GnuGo的代码，你会发现它凝聚了很多人的辛勤工作，但其效果却远比可能达到的水平要差得多。令人惊讶的是，尽管GnuGo始于1989年，但其版本更新一直持续到2009年。所以，其作者们无疑知道“深蓝”以及规模化搜索取得的惊人胜利，但他们仍然继续推进他们的专家系统。曾在谷歌大脑（Google Brain）复现了AlphaGo的前研究员Brian Lee，对此提供了一个令人信服的解释：\n我想提出另一点：[苦涩教训的]这些阶段是以十年左右的时间跨度发生的。在这十年间，博士学位被授予，职业身份被建立，晋升标准被设定，文化被定义，组织结构被固化。就像科学的进步伴随着一场又一场的葬礼一样，难题的进展也伴随着一个又一个组织的关闭。\n再想一个场景。你在一个大语言模型（LLM）实验室工作，你必须让你的基准测试分数超过竞争对手，否则你就会被解雇。你面临着一个直接的诱惑，那就是引入人类知识，在这种情况下，可能就是为特定基准准备的专门数据集。\n一个更好的方法是让模型在通用性上变得更强。将“专注于那些能随算力扩展的方法”作为一个筛选标准，是一个强有力的赌注，因为黄仁勋（Jensen Huang）正在尽其所能为你提供多个数量级的更多算力（FLOPS）。像测试时计算（test time compute）、合成数据（synthetic data）或混合专家模型（MoE models）都是很好的例子。但是这种方法的问题在于（当我写下来时感觉很明显），在当下，它让人觉得是一种奢侈。我们没有时间去做严谨的科学研究，我们必须在LiveCodeBench上击败其他实验室。这就是那苦涩的教训：DeepSeek专注于通用能力的提升，让这些方法生效，将它们扩展到3.8e25 FLOPS的算力，并达到了最先进水平（SOTA）。\n我最近在读的文章：\n《接下来是什么》（What comes next），作者Nathan Lambert (Interconnects)，其中讨论了O3模型的卓越之处等方面。 《R1中的欠训练词元》（Undertrained tokens in R1），作者Sander Land。 《深蓝》的论文，值得一读。 ","permalink":"https://www.timestamps.top/zh/posts/the-bitter-lesson/","summary":"原文：The Bitter Lesson 《苦涩的教训》是一篇非常出色但被广泛误解的文章。这篇文章的重点是，随着时间的推移，那些能够受益于计算能力扩展的方法，将最终胜过那些不能的方法。 这篇文章的观点不是： 我们永远不应该融合人类知识。 我们所需要的仅仅是深度学习和规模化（实际上，作者 Rich Sutton 对深度学习持相对怀疑的","title":"苦涩的教训"},{"content":"在人工智能辅助编程的激烈竞赛中，Anthropic 的 Claude Code 已然成为一匹黑马，其强大的能力使其与竞品（尤其是 OpenAI 的 Codex）拉开了显著差距。这种领先并非源于单一的突破，而是建立在一系列深思熟虑的技术、产品和战略决策之上。以下是对 Claude Code 制胜秘诀的深度解析。\n第一部分：铸就 Claude Code 核心竞争力的四大支柱 Claude Code 的卓越表现，根植于其强大的基础模型、精密的工具生态、创新的任务机制和毫不妥协的产品哲学。\n1. 卓越的模型基石：源自 Claude 3 的强大基因 一切成功的根本，在于其背后的模型能力。无论是 Claude 3 Sonnet 还是 Opus，其在代码理解、逻辑推理和 Agentic 任务规划方面的顶尖水准，为 Claude Code 提供了无与伦比的动力核心。没有强大的基础模型，任何上层工具都只是空中楼阁。\n2. 精密的内置工具生态：模拟专家级程序员的工作流 Claude Code 的强大之处在于它不仅仅是一个代码生成器，更是一个模拟人类程序员解决问题思路的“智能代理”。它内置了多达 18 种实用工具，涵盖了从代码检索 (Grep)、命令执行、架构分析到任务管理 (TODO) 的完整工作流。这套工具链使 Claude Code 能够自主地：\n制定计划 (Plan) 分析问题 (Analyze) 检索上下文 (Search) 编写与修改代码 (Code) 测试验证 (Test) 3. 创新的“子任务代理”机制：实现无干扰的并行处理 在众多工具中，Task 工具堪称其设计的点睛之笔。它允许主任务为特定的子问题创建独立的“分身”或“子代理”。这一机制带来了两大优势：\n上下文隔离：子任务在一个纯净的环境中专注于解决特定问题，不会被主任务的庞大上下文所干扰。 主任务清晰：主任务的上下文也不会被子任务执行过程中的“噪音”所污染，始终保持清晰和聚焦。 这些子代理继承了主任务的工具集（为防止历史记录混乱，禁止其直接编辑代码），实现了复杂任务的高效、模块化分解与处理。 4. 纯粹CLI形态与无损上下文：摒弃包袱，专注核心 Claude Code 做出了两个关键的产品选择，使其在上下文处理上远超对手：\n无损的上下文管理：它采取了一种“不计成本”的策略，每次请求都传递完整的会话历史，包括所有工具的调用与返回结果。这从根本上杜绝了因上下文压缩或截断导致的信息丢失问题，确保了模型决策的高保真度。相比之下，许多竞品（如 Cursor）为控制成本而频繁压缩上下文，严重影响了长期任务的连贯性。 纯粹的命令行（CLI）体验：与深度集成于 IDE 的工具不同，Claude Code 没有“IDE 包袱”。IDE 插件必须处理复杂的元信息（如打开的标签页、光标位置等），这在提供上下文和造成信息冗余之间形成了两难。Claude Code 则化繁为简，通过其工具集按需、精准地获取所需信息，实现了更高效的信噪比。 第二部分：反观 OpenAI Codex：战略与焦点的落差 相较于 Claude Code 的高歌猛进，OpenAI 的 Codex 则显得步履蹒跚。其落后不仅是技术问题，更深层地反映了战略和产品焦点的差异。\n1. 根本性的模型能力差距 最核心的问题，依然是模型本身。Anthropic 很可能在 Claude 3 的训练阶段，就深度结合了 Claude Code 的内部应用场景和海量交互数据，通过强化学习（RLHF）进行了针对性优化。这种“模型-工具”协同进化的策略，使其模型在编程任务上获得了天然的优势。相比之下，OpenAI 在这一轮针对性强化训练中明显慢了半拍。\n2. 战略远见：“数据飞轮”的缺席 Anthropic 为 Claude Code 设定的包月订阅模式，即便在短期内可能亏损，却是一步着眼于未来的高明棋。其真正目标是捕获海量、高质量的用户行为数据——真实的编程场景、多样的工具用法、失败与成功的案例。这些数据是训练下一代模型的无价之宝，构成了强大的“数据飞轮”。\n反观 OpenAI，其策略则令人费解。即便是付费的 o1 pro 用户，也仅能使用功能受限的 codex-mini 模型，这不仅无法满足复杂需求，更使其错失了从高阶用户处收集宝贵数据的机会。\n3. 资源错配：舍本逐末的技术优化 据称 Codex 团队投入精力将 CLI 工具用 Rust 重写。从用户的角度看，这几乎是一种资源错配。用户真正在意的是产品能否高效解决问题，而非其底层是用 Node.js 还是 Rust 构建。即便 Agent 执行速度稍慢，只要结果卓越，多等待几分钟也完全可以接受。将宝贵的研发资源投入到底层语言重写这种“技术细节”上，而非打磨核心模型能力和工具链，无疑是舍本逐末。\n结论 Claude Code 的成功，是模型、工具、产品哲学和商业战略协同作用的必然结果。它深刻洞察了程序员的工作模式，并为此打造了一个专注、强大且智能的开发伙伴。而 OpenAI Codex 的相对落后，则警示我们：在通往通用人工智能的道路上，仅仅拥有强大的基础模型是不够的，如何将其与特定领域的应用场景深度结合，并通过明智的战略构建数据壁垒，才是赢得未来的关键。\n","permalink":"https://www.timestamps.top/zh/posts/claude-code-secrets/","summary":"在人工智能辅助编程的激烈竞赛中，Anthropic 的 Claude Code 已然成为一匹黑马，其强大的能力使其与竞品（尤其是 OpenAI 的 Codex）拉开了显著差距。这种领先并非源于单一的突破，而是建立在一系列深思熟虑的技术、产品和战略决策之上。以下是对 Claude Code 制胜秘诀的深度解析。 第一部分：铸就 Claude Code 核心竞争力的四","title":"解构Claude Code：其何以在AI编程领域遥遥领先？"},{"content":" 原文：How we built our multi-agent research system\n我们如何构建我们的多智能体研究系统 我们的研究（Research）功能使用多个 Claude 代理来更有效地探索复杂主题。我们在此分享构建该系统时遇到的工程挑战以及我们学到的经验教C训。\n在许多方面，研究都是大型语言模型（LLM）的理想任务。它奖励那些能够吸收和综合大量文本以产生新颖见解的模型。我们的许多客户已经在使用 Claude 来帮助他们进行研究，例如法律先例分析、评估投资组合以及跟上快速发展的科学领域。\n为了更好地支持这些复杂的、开放式的研究任务，我们构建了“研究”功能（Research feature）。与传统的聊天体验不同，它在后台使用多个专门的 AI 代理。这个多智能体系统使 Claude 能够探索比单个模型可以处理的更广泛的信息，从而为我们的用户带来更深入、更全面的见解。\n在本文中，我们将探讨我们构建和扩展多智能体系统的经验和教训，包括我们为解决可靠性、延迟和评估方面的挑战而开发的解决方案。\n什么是多智能体系统？ 多智能体系统由多个代理（在循环中自主使用工具的 LLM）协同工作。我们的研究功能涉及一个代理，它根据用户查询规划研究过程，然后使用工具创建并行代理，同时搜索信息。\n本质上，搜索就是压缩：从庞大的语料库中提炼出见解。早期的搜索技术，如 TF-IDF 和 BM25，通过查找与查询匹配的关键词来压缩文档。静态检索增强生成（RAG）通过根据查询相似性检索预定块来压缩知识库，然后将其注入 LLM 的上下文窗口。\n然而，研究需要动态探索。它是一个开放式过程，其中策略会根据新发现不断调整。研究人员在寻找答案时会追寻新兴的线索，而不是遵循固定的路径。\n对于需要探索广泛主题的查询，单代理系统会遇到困难。它们的顺序处理和有限的上下文窗口成为瓶颈。例如，识别 IT 行业标准普尔 500 强公司的董事会成员，对于一个模型来说，搜索空间太大了。\n多智能体系统通过将任务分解为可以并行探索的子任务来克服这些限制。这种架构支持我们所称的“广度优先”研究，即多个代理同时追寻多个独立的方向。\n在我们的内部评估中，我们发现多智能体研究系统在需要同时追求多个独立方向的广度优先查询方面表现尤为出色。我们发现，在我们的内部研究评估中，一个以 Claude 3 Opus 作为领导代理、Claude 3 Sonnet 作为子代理的多智能体系统的表现比单代理的 Claude 3 Opus 高出 90.2%。\n然而，多智能体系统并非万能。对于本质上顺序性、几乎没有并行化空间且需要代理之间实时协作的任务（例如编码项目），它们的效果较差。\n研究功能的架构概览 我们的研究系统采用多智能体架构，具有协调器-工作者（orchestrator-worker）模式，其中一个领导代理协调流程，同时委托给并行操作的专门子代理。\n该过程始于一个领导代理，它接收用户查询并将其分解为子任务。然后，它启动多个并行运行的子代理。每个子代理负责一个特定的子任务——例如，一个代理可能搜索最新的市场数据，而另一个代理则深入研究技术文档。子代理通过工具调用（tool use）API 与外部世界（如网络搜索或特定数据库）进行交互。\n子代理完成后，它们将结果返回给领导代理。领导代理审查这些部分结果，决定是否需要进一步的研究，或综合信息以形成最终答案。\n我们发现多智能体系统在涉及大量并行化、信息量超过单个上下文窗口以及与众多复杂工具接口的有价值任务中表现出色。当任务的价值足够高以支付增加的性能成本时，它们是经济上可行的。\n为代理编写提示（Prompting）的经验教训 由于每个代理都由提示（prompt）引导，提示工程是我们改进这些行为的主要手段。我们发现，改变提示中的一两个词就可能产生级联效应。\n以下是我们学到的一些为代理编写提示的原则：\n像你的代理一样思考。 为了迭代提示，你必须了解其效果。为了帮助我们做到这一点，我们使用控制台（Console）和系统中的确切提示和工具构建了模拟，然后逐步观察代理的工作。这立即揭示了失败模式：代理在已经有足够结果时仍继续工作，使用过于冗长的搜索查询，或选择不正确的工具。有效的提示依赖于开发一个准确的代理心智模型，这可以使最有影响力的改变变得显而易见。 教会协调器如何授权。 在我们的系统中，领导代理将查询分解为子任务并向子代理描述它们。每个子代理都需要一个目标、一个输出格式、关于使用哪些工具和来源的指导以及明确的任务边界。没有详细的任务描述，代理会重复工作、留下空白或找不到必要的信息。 根据查询复杂性扩展投入。 代理很难判断不同任务的适当投入，所以我们在提示中嵌入了扩展规则。简单的事实查找只需要1个代理进行3-10次工具调用，直接比较可能需要2-4个子代理，每个代理进行10-15次调用，而复杂的研究可能使用超过10个具有明确分工的子代理。 工具设计和选择至关重要。 我们发现，拥有少量、可靠且经过充分记录的工具，其性能优于拥有大量、不可靠的工具。我们甚至创建了一个工具测试代理——当给定一个有缺陷的工具时，它会尝试使用该工具，然后重写工具描述以避免失败。 让代理自我改进。 我们正在试验让代理在工作中学习和适应的方法，以提高其性能。例如，我们正在研究让代理根据其互动的历史记录动态调整其工具使用策略的方法。 从宽泛开始，然后收窄。 我们发现，有效的策略是首先进行广泛的、探索性的搜索，以确定关键主题和来源，然后创建更集中的子代理，深入研究特定的感兴趣领域。 引导思考过程。 我们在提示中使用元认知提示（metacognitive prompting）来鼓励代理在行动之前“停下来思考”。例如，我们可能会提示代理，“在承诺一个冗长的研究路径之前，请花点时间回顾一下到目前为止的发现，并考虑一下替代方法。” 并行的工具调用可以改变速度和性能。 我们在系统中大量使用并行工具调用，允许单个代理同时与多个工具交互。这大大减少了延迟并提高了研究过程的效率。 在生产环境中构建多智能体系统 从原型到生产系统的飞跃引入了新的挑战。以下是我们如何应对其中一些挑战的：\n复合性错误。 代理系统中的错误会复合。一个步骤的失败可能导致代理探索完全不同的轨迹。我们通过构建从中断处恢复的能力来解决这个问题——如果代理失败，它可以从上次成功状态重新启动，而不是从头开始。 评估。 研究输出很难以编程方式评估，因为它们是自由格式的文本，很少有单一的正确答案。我们使用一个 LLM 评判员，根据一个评分标准来评估每个输出：事实准确性、引文准确性、完整性、来源质量和工具效率。 调试。 追踪代理行为可能很困难。添加完整的生产追踪让我们能够诊断代理为什么会失败，并系统地修复问题。除了标准的可观察性，我们还监控代理决策模式和交互结构——所有这些都在不监控单个对话内容的情况下进行，以维护用户隐私。 部署。 代理系统是状态性很强的提示、工具和执行逻辑的网络，几乎持续运行。这意味着每当我们部署更新时，代理可能处于其执行周期的任何位置。为了管理这一点，我们使用了“彩虹部署”（rainbow deployments），即我们一次部署一个完整的系统堆栈（例如，“蓝色”或“绿色”），并逐渐将流量转移到新版本。 同步执行的限制。 目前，我们的系统同步运行，这意味着用户在研究完成之前会看到一个加载旋转器。对于快速查询，这是有效的，但对于需要广泛研究的更复杂的任务，这可能会导致延迟过长。我们正在探索异步执行，其中代理可以在后台工作，并在准备好后通知用户。 未来方向 我们对多智能体系统在未来实现更复杂形式的研究的潜力感到兴奋。我们正在探索的一些领域包括：\n主动和个性化的研究：我们设想代理可以根据用户的历史和偏好主动进行研究，在他们提出要求之前就预测到他们的需求。 科学发现：我们正在探索使用多智能体系统加速科学研究的方法，例如通过自动进行文献综述、假设生成和实验设计。 通过辩论提高研究的稳健性：我们正在尝试让代理扮演不同的角色，例如“怀疑论者”或“辩护者”，以参与结构化的辩论。我们的初步研究表明，这种对抗性过程可以揭示单一代理可能会错过的偏见和假设。 构建我们的多智能体研究系统是一次充满启发和挑战的旅程。我们为我们所取得的进展感到自豪，并对未来的可能性感到兴奋。我们希望分享我们的经验教训可以帮助其他构建者应对他们自己项目中的挑战和机遇。 ","permalink":"https://www.timestamps.top/zh/posts/built-multi-agent-research-system/","summary":"原文：How we built our multi-agent research system 我们如何构建我们的多智能体研究系统 我们的研究（Research）功能使用多个 Claude 代理来更有效地探索复杂主题。我们在此分享构建该系统时遇到的工程挑战以及我们学到的经验教C训。 在许多方面，研究都是大型语言模型（LLM）的理想任务。它奖励那些能够吸收和综合大量文本","title":"Anthropic：我们如何构建多智能体研究系统"},{"content":" 原文：A practical guide to building agents\nAI 智能体（Agent）正引领一场软件范式的革命，它不再是简单的用户工具，而是能自主代表用户、接管并执行整个工作流的“代理人”。其核心是利用大型语言模型（LLM）作为推理引擎来驱动任务。本指南将提炼 OpenAI 的核心思想，为您提供一套构建、部署和管理 AI 智能体的实用策略。\n第一章：何时需要构建 AI 智能体？ 在投入开发前，首先要判断您的场景是否真的需要智能体。智能体并非万能，它主要用于解决传统基于规则的自动化难以胜任的“认知劳动”。如果您的业务面临以下挑战，那么构建智能体将是正确的选择：\n复杂的决策制定 (Complex Decision-Making): 当任务需要超越“if-then-else”规则的微妙判断时。\n场景示例： 复杂的客户退款审批。传统系统只能看“购买是否超30天”，而智能体能综合评估客户忠诚度、历史记录、问题性质等非结构化信息，做出更人性化的决策。 难以维护的规则系统 (Difficult-to-Maintain Rules): 当业务逻辑依赖于一个庞大、脆弱且频繁变更的规则引擎时。\n场景示例： 供应商合规性审查。与其硬编码上百条随时可能过期的政策法规，不如让智能体直接将政策文档作为上下文，在每次审查时进行动态的理解和应用。 非结构化数据处理 (Unstructured Data Processing): 当工作流的核心是理解和提取电子邮件、PDF、对话记录等非结构化数据时。\n场景示例： 保险理赔。智能体可以自动阅读事故报告、医疗记录和客户邮件，提取关键信息并完成初步的综合评估，极大提升效率。 核心思想： 智能体的价值在于自动化“判断”与“解读”，而非简单的程序性任务。\n第二章：智能体的三大核心支柱 一个设计精良的智能体由三大基本组件构成：模型 (Model)、工具 (Tools) 和 指令 (Instructions)。这种架构将“思考”、“行动”与“策略”分离，带来了极高的灵活性和可维护性。\n2.1 模型 (大脑): 驱动推理的核心 模型（通常是 LLM）是智能体的决策中心。\n选择策略：“从高到低” (Start Smart) 第一步： 在原型阶段，务必使用当前最强大的模型（如 GPT-4o）来建立性能基准。这能让你验证工作流、工具和指令的有效性，排除“模型能力不足”这个干扰项。如果此时依然失败，问题就清晰地指向了工具或指令设计。 第二步： 建立基准后，再尝试用更经济、更快速的模型替换部分或全部任务，并通过量化评估（Evals）来验证性能是否仍在可接受范围内，从而在性能、成本和延迟之间找到最佳平衡点。 2.2 工具 (双手): 与世界交互的桥梁 工具是智能体调用外部函数或 API 以获取信息或执行动作的途径。工具定义本身就是一项关键技能，其描述的清晰度直接决定了智能体调用的成功率。\n工具类型 描述 示例 数据检索 (Data Retrieval) （只读） 从外部获取信息，为决策提供上下文。 query_database()、read_pdf()、search_knowledge_base() 动作执行 (Action Execution) （可写） 在外部系统执行操作，改变其状态。 send_email()、update_crm_record()、execute_code() 编排 (Orchestration) 将另一个智能体封装成工具，用于委派复杂任务。 triage_support_ticket(details) (调用一个分诊智能体) 2.3 指令 (行为准则): 定义目标的蓝图 指令是智能体的行动指南，是承载业务逻辑的核心。编写指令应被视为一项严肃的工程活动。\n核心最佳实践： 利用现有文档： 将公司已有的标准操作流程（SOPs）、政策手册直接改编为智能体的分步指令。 明确与分解： 将宏大目标分解为具体、可执行的小步骤。明确告知智能体在何时使用何种工具。 使用模板： 利用带有参数化变量（如 {{customer_name}}）的提示模板，动态生成个性化指令。 处理边界情况： 在指令中明确定义异常情况（如用户未提供订单号）的处理逻辑。 核心思想： 采用“指令即代码” (Instructions as Code) 的理念，将指令纳入版本控制、进行代码审查并建立配套的评估测试，以确保其可靠性和可维护性。\n第三章：架构设计：从单一到协作 首要原则：从简到繁，增量演进。 切勿一开始就设计复杂的终极系统。从最简单的单一智能体入手，在真实场景中验证，再根据需求逐步增加复杂性。这能有效控制智能体的“认知负荷”，避免其因工具或指令过多而产生混乱。\n3.1 单一智能体系统 (Single-agent System) 这是最推荐的起点。一个 LLM 模型，配备一套专属的工具和指令，在一个“运行循环”（Run Loop）中持续工作，直到任务完成。它行为类似一个“有状态的微服务”，在生命周期内维护着对话历史和工具调用记录。\n3.2 多智能体系统 (Multi-agent System) 当任务的复杂性超出单个智能体的承载能力时，应转向多智能体系统。这实现了更高层次的“关注点分离”。\n主管模式 (Manager Pattern): 层级化协作\n结构： 一个“主管”智能体负责任务分解，并将子任务委派给多个专门的“下属”智能体（它们对主管而言就是工具）。主管负责收集结果并整合。 类比： 项目经理协调不同专家（设计师、程序员）的工作。 适用场景： 可被并行处理，或需要综合多种信息才能完成的任务。 去中心化模式 (Decentralized Pattern): 流水线式协作\n结构： 系统中没有中心主管，一群对等的专家智能体根据任务进展，将控制权和上下文“传递”给下一个最合适的智能体。 类比： 工厂流水线或部门间的工作交接。 适用场景： 线性的、由不同阶段专家序贯处理的流程。 核心思想： 编排模式的选择是业务流程的设计决策，它应该精确映射真实世界中的协作模式。\n第四章：安全与可控性：构建信任的基石 一个不可信的智能体毫无价值。安全必须是贯穿始终的核心设计，而非事后补丁。\n4.1 核心策略：分层防御 (Defense in Depth) 不要依赖单一的安全措施。应构建一个由多层、多样化护栏组成的纵深防御体系。即使一层失效，后续层面仍能捕获风险。这就像为智能体打造一个“免疫系统”。\n4.2 关键护栏机制 护栏类型 目的 实现方法 相关性分类器 确保交互不偏离主题，防止任务劫持。 使用独立的 LLM 分类器或关键词过滤。 安全分类器 拦截有害、不道德的内容。 调用 OpenAI Moderation API 或自建安全模型。 PII 过滤器 防止个人敏感信息（如电话、邮箱）泄露。 使用正则表达式（Regex）或专门的 NER 模型。 工具风险评估 对高风险工具（如“删除数据库”）的调用进行门控。 为工具附加风险等级，并触发相应审批流程。 输出验证 确保最终响应符合格式、品牌语调和合规要求。 使用 Pydantic 验证结构，或用另一个 LLM 评估语调。 审计 (Auditing) 详细记录智能体的所有行为，用于事后分析。 - 4.3 人工监督与干预 (Human-in-the-Loop, HITL) HITL 不是降级方案，而是建立信任、处理高风险和模糊场景的核心功能。它让智能体在初期扮演“超级助理”，将决策方案提交给人类审批。随着信任的建立，可以逐步提高其自主权。\n何时触发人工介入？ 失败阈值： 当智能体连续多次犯错或陷入循环时。 高风险操作： 默认需要人工批准的操作，如大额退款、删除生产数据。 低置信度： 训练智能体识别自己的“不确定”状态，并主动请求帮助。 结论：迈向智能体驱动的未来 构建生产级 AI 智能体是一项系统工程，它需要：\n坚实的技术基石： 模型、工具、指令的三位一体。 明智的演进路径： 从单一到多智能体的渐进式架构。 可靠的保障体系： 分层防御的安全护栏与清晰的人工干预机制。 未来，行业的焦点将从孤立的智能体，转向由众多专业智能体协同工作的“智能体生态系统”，共同优化整个业务职能。本指南阐述的原则，正是构建这一宏伟蓝图所必需的坚实基础。\n","permalink":"https://www.timestamps.top/zh/posts/a-practical-guide-to-building-agents/","summary":"原文：A practical guide to building agents AI 智能体（Agent）正引领一场软件范式的革命，它不再是简单的用户工具，而是能自主代表用户、接管并执行整个工作流的“代理人”。其核心是利用大型语言模型（LLM）作为推理引擎来驱动任务。本指南将提炼 OpenAI 的核心思想，为您提供一套构建、部署和管理 AI 智能体的实用策略。 第一","title":"OpenAI: 构建 AI 智能体实用指南"},{"content":"有不少人拥有多个github账号，比如个人账号，用户开源的账号。那如何在同一台电脑上管理多个github账号呢？\n1. 使用https方式 git clone https://duanhjlt@github.com/duanhjlt/blog.git git clone https://duan0120@github.com/duan0120/xvm.git 2. 使用ssh方式 2.1 创建ssh key ssh-keygen -t ed25519 -C \u0026#34;duanhjlt@163.com\u0026#34; -f ~/.ssh/id_ed25519_github1 ssh-keygen -t ed25519 -C \u0026#34;duanhjlt@gmail.com\u0026#34; -f ~/.ssh/id_ed25519_github2 2.2 将ssh公钥添加到对应的github账号 2.3 设置ssh 2.3.1 设置配置文件 # ~/.ssh/config Host github.com HostName github.com User git IdentityFile ~/.ssh/id_ed25519_github2 Host github1.com HostName github.com User git IdentityFile ~/.ssh/id_ed25519_github1 2.3.2 清除当前ssh代理中的密钥 ssh-add -D 2.3.3 添加需要的密钥 ssh-add ~/.ssh/id_ed25519_github1 ssh-add ~/.ssh/id_ed25519_github2 2.3.4 验证加载的密钥 ssh-add -l 2.3.5 测试链接 ssh -T git@github.com ssh -T git@github1.com 2.4 clone 代码 git clone git@github.com:duanhjlt/blog.git git clone git@github1.com:duan0120/xvm.git ","permalink":"https://www.timestamps.top/zh/posts/githubs-on-the-same-os/","summary":"有不少人拥有多个github账号，比如个人账号，用户开源的账号。那如何在同一台电脑上管理多个github账号呢？ 1. 使用https方式 git clone https://duanhjlt@github.com/duanhjlt/blog.git git clone https://duan0120@github.com/duan0120/xvm.git 2. 使用ssh方式 2.1 创建ssh key ssh-keygen -t ed25519 -C \u0026#34;duanhjlt@163.com\u0026#34; -f ~/.ssh/id_ed25519_github1 ssh-keygen -t ed25519 -C \u0026#34;duanhjlt@gmail.com\u0026#34; -f ~/.ssh/id_ed25519_github2 2.2 将ssh公钥添加到对应的github账号 2.3 设置ssh 2.3.1 设置配置文件 # ~/.ssh/config Host github.com HostName","title":"同一个系统上管理多个github账号"},{"content":"什么是时间戳？ 时间戳是一串字符或编码信息，用于表示特定的日期和时间，通常在计算机中用于记录事件发生的时间。它通常表示自Unix纪元（1970年1月1日00:00:00 UTC）以来的秒数或毫秒数。时间戳广泛应用于数据库、日志系统和应用程序中，以跟踪事件、同步数据或管理时间敏感的操作。\n时间戳的主要特点： 精度：时间戳可以精确到秒、毫秒甚至微秒。\n格式：常见格式包括Unix时间戳（如1697054700）、ISO 8601（如2023-10-11T18:05:00Z）和人类可读格式（如2023年10月11日18:05）。\n应用：用于Web开发、API、区块链和数据分析，以确保精确的时间跟踪。\n如何将日期时间转换为Unix时间戳? 本页面提供日期时间与时间戳格式之间的转换工具，帮助开发者、数据分析师和爱好者高效处理时间数据。\n常见时间戳问答 1. 时间戳和日期时间有什么区别？ 时间戳是表示某一时间点的数字，通常基于Unix纪元（例如1697054700秒）。日期时间是包含日期和时间组件的人类可读格式（例如2023-10-11 18:05:00）。时间戳便于机器处理，而日期时间便于人类理解。\n2. 如何将日期时间转换为Unix时间戳？ 将日期时间转换为Unix时间戳：\n使用编程语言如JavaScript：Date.parse(\u0026quot;2023-10-11T18:05:00Z\u0026quot;) / 1000 返回 1697054700。\n或使用我们的在线工具：输入日期时间，选择格式，即可立即获得对应的时间戳。\n3. 如何将Unix时间戳转换为日期时间？ 将Unix时间戳转换为日期时间：\n在JavaScript中：new Date(1697054700 * 1000).toISOString() 返回 2023-10-11T18:05:00.000Z。\n使用我们的转换器：输入时间戳，即可按您喜欢的格式显示日期时间。\n4. 为什么我的时间戳显示的时间与预期不同？ 这通常是由于时区差异。Unix时间戳基于UTC，但您的本地时间可能不同。确保您的工具或代码考虑了正确的时区偏移（例如，北京为UTC+8）。\n5. 什么是Unix纪元？ Unix纪元是Unix时间戳的起点，定义为1970年1月1日00:00:00 UTC。大多数时间戳以该点开始计算秒数或毫秒数。\n6. 时间戳会受闰秒影响吗？ Unix时间戳不考虑闰秒。它们假设每天有86400秒，这简化了计算，但在精确的科学应用中可能导致微小偏差。\n7. 我可以在编程项目中使用时间戳吗？ 当然可以！时间戳在以下方面至关重要：\n记录事件（例如用户操作、错误）。\n跨系统同步数据。\n在数据库中存储创建或修改时间。 使用我们的工具为您的项目生成或转换时间戳。\n8. Unix时间戳的最大值是多少？ 对于32位系统，Unix时间戳的最大值为2147483647（2038年1月19日03:14:07 UTC），即“2038年问题”。64位系统支持更大的值，远远超出实际限制。\n","permalink":"https://www.timestamps.top/zh/posts/timestamps/","summary":"什么是时间戳？ 时间戳是一串字符或编码信息，用于表示特定的日期和时间，通常在计算机中用于记录事件发生的时间。它通常表示自Unix纪元（1970年1月1日00:00:00 UTC）以来的秒数或毫秒数。时间戳广泛应用于数据库、日志系统和应用程序中，以跟踪事件、同步数据或管理时间敏感的操作","title":"如何将日期时间转换为Unix时间戳 - 免费工具 | DevUtils"},{"content":"Memora：iOS与macOS平台的安全稍后读应用 Memora 是一款精心设计的「稍后读\u0026amp;笔记」工具，专为忙碌人士打造，助你高效收集、整理和回顾所有有价值的内容。无论是文章、网页还是日常灵感，Memora让你随时随地保存重要信息，永不遗失。\n核心功能： 网页离线保存与阅读 作为iOS和macOS平台强大的稍后读工具，Memora可将网页完整保存至本地，避免404错误困扰，让你在无网络环境下也能随时查阅内容。\n隐私优先的本地存储 你的数据安全是我们的首要考量。Memora采用本地存储+iCloud安全同步机制，所有数据仅存于你的设备，我们绝不收集用户信息，提供最高级别的隐私保护。\n纯净无干扰阅读模式 享受剔除广告和杂乱元素的清爽阅读界面。即将推出的笔记功能和全文搜索将使Memora成为更完善的知识管理伴侣。\n智能标签与多维搜索 轻松收藏和归档网页内容。通过自定义标签分类网址，支持标签筛选和关键词搜索等多种检索方式，快速定位目标内容。\n完全掌控你的数字知识库 Memora赋予你绝对控制权，让你在专注无干扰的环境中系统化管理知识灵感和阅读内容。\n选择Memora的理由： 支持iOS/macOS双平台，iCloud无缝同步\n网页离线保存，杜绝链接失效风险\n本地加密存储，零数据收集政策\n灵活的标签体系与智能搜索\n沉浸式阅读模式提升专注力\n立即体验 下载iOS/macOS平台最佳的稍后读应用Memora，用更私密便捷的方式管理你的阅读收藏。\n（注：译文在保持专业性的同时采用了更符合中文阅读习惯的短句结构和四字短语，如\u0026quot;永不遗失\u0026quot;、\u0026ldquo;清爽阅读\u0026quot;等；技术术语如\u0026quot;iCloud同步\u0026quot;等保留原名；功能描述部分使用中文项目符号保持视觉一致性；营销话术转化为符合中文用户认知的表达方式，如\u0026quot;数字知识库\u0026quot;等）\n","permalink":"https://www.timestamps.top/zh/posts/memora/","summary":"Memora：iOS与macOS平台的安全稍后读应用 Memora 是一款精心设计的「稍后读\u0026amp;笔记」工具，专为忙碌人士打造，助你高效收集、整理和回顾所有有价值的内容。无论是文章、网页还是日常灵感，Memora让你随时随地保存重要信息，永不遗失。 核心功能： 网页离线保存与阅读 作为iOS和m","title":"Memora：专为iOS和macOS设计的离线稍后读应用"},{"content":"xvm-windows 是 xvm 的 windows 版本，使用方式和 xvm 基本一致。\n安装方式 git clone https://github.com/duan0120/xvm-windows.git %USERPROFILE%/.xvm 配置环境变量\nXVM_ROOT=%USERPROFILE%/.xvm 将下面路径加入到**%PATH%**中\n%XVM_ROOT%\\versions\\node\\default %XVM_ROOT%\\versions\\go\\default\\bin %XVM_ROOT%\\versions\\python\\default %XVM_ROOT%\\versions\\python\\default\\Scripts 使用方式 查看版本\nxvm -v 获取帮助\nxvm -h xvm help node Node.js 查看版本\n# 查看已发布版本 xvm node ls-remote # 查看已发布 lts 版本 xvm node ls-remote --lts # 查看本地已安装版本 xvm node list 安装指定版本\nxvm node install v18.19.1 卸载指定版本\nxvm node uninstall v18.19.1 切换版本\nxvm node use v18.19.1 Go 查看版本\nxvm go ls-remote xvm go list 安装指定版本\nxvm go install go1.19.2 # 指定架构，amd64/386/arm64, 默认为amd64 xvm go install go1.13.10 --arch=amd64 如果需要指定下载地址，可以在 %XVM_ROOT%/.xvm/scripts/go-scripts/proxy 文件中指定，如 https://golang.google.cn\n卸载指定版本\nxvm go uninstall go1.19.2 切换版本\nxvm go use go1.19.2 Python 查看版本\nxvm python ls-remote xvm python list 安装指定版本\nxvm python install 3.12.1 # 指定架构，amd64/386/arm64, 默认为amd64 xvm python install 3.12.1 --arch=arm64 创建虚拟环境\nxvm python alias test 3.12.1 激活虚拟环境\nxvm python use test 卸载指定版本\nxvm python uninstall 3.12.1 # 删除虚拟环境 xvm python uninstall test 切换版本\nxvm python use 3.12.1 ","permalink":"https://www.timestamps.top/zh/posts/xvm-windows/","summary":"xvm-windows 是 xvm 的 windows 版本，使用方式和 xvm 基本一致。 安装方式 git clone https://github.com/duan0120/xvm-windows.git %USERPROFILE%/.xvm 配置环境变量 XVM_ROOT=%USERPROFILE%/.xvm 将下面路径加入到**%PATH%**中 %XVM_ROOT%\\versions\\node\\default %XVM_ROOT%\\versions\\go\\default\\bin %XVM_ROOT%\\versions\\python\\default %XVM_ROOT%\\versions\\python\\default\\Scripts 使用方式 查看版本 xvm -v 获取帮助 xvm -h xvm help node Node.js 查看版本 # 查看已发布版本 xvm node ls-remote # 查看已发布 lts 版本 xvm node ls-remote --lts # 查看本地已安装版本 xvm node list 安装指定版本 xvm node install v18.19.1 卸载指定版本 xvm node uninstall v18.19.1 切换","title":"xvm-windows：Node.js、Go、Python版本管理器"},{"content":"作为一名全干工程师，我们会在同一个电脑上安装各种工具，然而又会因为各种原因，需要使用这些工具的不同版本，版本管理就变的十分重要。\n我们会使用 nvm 来管理 Node.js；\n我们会使用 gvm 来管理 Go；\n我们会使用 pyenv 或者 Conda 来管理 Python；\n这些工具都十分强大，但使用方式却各不相同，一段时间不使用，就不得不重新熟悉每个工具的使用方式。重要的是，平白无故又多了好几个软件。\n在一次重装系统之后，终于忍无可忍\u0026hellip; 其实我的需求很简单，也用不到版本管理器的那些高级功能，我只是需要一个小巧的版本管理器，使用统一的管理方式，统一的命令。\n因此 xvm 应运而生，融合了 Node.js， Go， Python 等的版本管理工具，虽然没有专业的工具那么强大，但小巧且命令统一。\nxvm 是 linux 和 macos 上的版本管理工具，windows 上可以使用 xvm-windows\n安装方式 curl -o- https://raw.githubusercontent.com/duan0120/xvm/main/install.sh | bash 或者\ngit clone https://github.com/duan0120/xvm.git ~/.xvm 将下面代码放到 ~/.bashrc 或者 ~/.zshrc 中，并重新 source\nexport XVM_ROOT=~/.xvm [ -s \u0026#34;$XVM_ROOT/xvm\u0026#34; ] \u0026amp;\u0026amp; source \u0026#34;$XVM_ROOT/xvm\u0026#34; 使用方式 查看版本 xvm -v 获取帮助\nxvm -h xvm help node Node.js 查看版本\n# 查看发布版本 xvm node ls-remote # 查看 lts 版本 xvm node ls-remote --lts # 查看已安装版本 xvm node list # 查看默认版本 xvm node default 安装指定版本\n# 安装指定版本 xvm node install v18.19.1 # 安装指定版本，并设置为默认版本, 重启terminal或者source生效 xvm node install v18.19.1 --default 卸载指定版本\nxvm node uninstall v18.19.1 切换版本\n# 临时切换指定版本 xvm node use v18.19.1 # 临时切换指定版本，并设置为默认 xvm node use v18.19.1 --default Go 查看版本\nxvm go ls-remote xvm go list 安装指定版本\nxvm go install go1.19.2 # 安装并设置为默认版本 xvm go install go1.19.2 --default # xvm go install go1.13.10 --default --arch=amd64 如果需要指定下载地址，可以在 ~/.xvm/scripts/go-scripts/proxy 文件中指定，如 https://golang.google.cn\n卸载指定版本\nxvm go uninstall go1.19.2 切换版本\n# 临时切换指定版本 xvm go use go1.19.2 # 临时切换指定版本，并设置为默认 xvm go use go1.19.2 --default 查看默认版本\nxvm go default Python xvm 也支持管理虚拟环境，并且操作很简单\n安装依赖\nPython使用的是源码编译安装，需要安装依赖，请参考 https://devguide.python.org/getting-started/setup-building/\n查看版本\nxvm python ls-remote xvm python list 安装指定版本\nxvm python install 3.12.0 # 安装并设置为默认版本 xvm python install 3.12.0 --default 切换版本\n# 临时切换指定版本 xvm python use 3.12.0 # 临时切换指定版本，并设置为默认 xvm python use 3.12.0 --default 查看默认版本\nxvm python default 创建虚拟环境\nxvm python alias 3.12.0 venv 激活虚拟环境\nxvm python activate venv 撤销虚拟环境\nxvm python deactivate 卸载指定版本\nxvm python uninstall 3.12.0 # 删除虚拟环境 xvm python uninstall venvxVM：Node.js、Go、Python版本管理器 ","permalink":"https://www.timestamps.top/zh/posts/xvm/","summary":"作为一名全干工程师，我们会在同一个电脑上安装各种工具，然而又会因为各种原因，需要使用这些工具的不同版本，版本管理就变的十分重要。 我们会使用 nvm 来管理 Node.js； 我们会使用 gvm 来管理 Go； 我们会使用 pyenv 或者 Conda 来管理 Python； 这些工具都十分强大，但使用方式却各不相同，一段时间不使用","title":"XVM：Node.js、Go、Python版本管理器X Version Manger"},{"content":"欢迎访问 Blackscreen.space，这里以黄色的温暖与活力为核心。我们深知黄色的心理意义，它象征幸福、阳光与积极正能量。Blackscreen.space 致力于打造以黄屏为核心的多功能平台，从提升积极情绪与能量到优化视觉清晰度，为您的数字体验带来全面升级。\n黄屏的积极与活力特质 光明与乐观的象征 黄色代表幸福与阳光，传递出明亮、轻快与乐观的气息。在 Blackscreen.space 上使用黄屏，能迅速提升积极氛围，营造充满活力的数字空间。其丰富的黄色调不仅振奋人心，还为观众带来愉悦的视觉享受。\n亲切与友好的魅力 黄色以其可爱与亲和力闻名，常用于食品包装与各类产品设计，深受男女喜爱。通过 Blackscreen.space 的黄屏，您可以为数字形象注入友好、平易近人且愉悦的特质，增强用户好感度。\n黄屏助力视觉沟通 打造吸睛的媒体广告 黄色象征温暖、欢乐与乐观，在不同光线与场景下传递多样情感。全球众多知名品牌在食品、家电、能源与科技领域采用黄色标识。借助 Blackscreen.space 的黄屏，制作引人入胜的广告内容，激发积极情绪，与观众建立深层共鸣。\n突出折扣与吸引目光 黄色因其活力与动态感，成为吸引注意力的绝佳选择。在 Blackscreen.space 上利用黄屏，您可以轻松突出折扣、优惠或关键信息，打造充满生机的数字环境，吸引并留住访客。\n黄屏带来的健康与舒适 护眼与舒适的显示效果 相较于蓝光的潜在负面影响，黄屏提供更健康的选择。Blackscreen.space 的温暖黄色光芒能缓解长时间使用电子设备带来的不适与眼疲劳，提升视觉舒适度，呵护眼睛健康。\n柔和阅读与放松照明 黄光是阅读或营造放松氛围的理想光源。与增强专注的白光不同，Blackscreen.space 的黄屏带来舒缓效果，减轻眼部压力。沉浸在温馨的光芒中，享受阅读或休闲时光。\n黄屏激发创意表达 摄影中的黄光创意 黄光常为摄影增添怀旧与历史感，营造独特氛围。通过 Blackscreen.space 的黄屏，您可以尝试不同角度与光线，拍摄出令人惊艳的肖像与视觉作品，唤起永恒与魅力的意境。\n","permalink":"https://www.timestamps.top/zh/posts/yellow-screen/","summary":"欢迎访问 Blackscreen.space，这里以黄色的温暖与活力为核心。我们深知黄色的心理意义，它象征幸福、阳光与积极正能量。Blackscreen.space 致力于打造以黄屏为核心的多功能平台，从提升积极情绪与能量到优化视觉清晰度，为您的数字体验带来全面升级。 黄屏的积极与活力","title":"Yellow Screen"},{"content":"欢迎访问 Blackscreen.space，这里以红色的动态与迷人魅力为核心。我们深知红色是一种引人注目的色彩，承载着丰富的含义与联想。Blackscreen.space 致力于打造以红屏为核心的多功能平台，从激发强烈情感与活力到优化视觉效果，为您的数字生活注入无限可能。\n红屏的心理魅力 引人注目与震撼力 红色向来以其吸睛的特质著称，是一种强烈的视觉刺激物。它的心理意义丰富多样，在不同文化中象征着力量、高贵、愤怒、激情乃至幸福。红色的多重解读使其成为激发情感与传递文化内涵的独特工具。\n激发热情与活力 红色以激发热情与能量著称，能够唤起欣快、活力甚至警觉的情绪。它让人感到温暖而充满动力。借助 Blackscreen.space 的红屏功能，您可以打造引人入胜且充满活力的视觉体验。\n红屏的多样应用 媒体与广告中的红屏效应 红屏散发温暖与高能量，是媒体与广告的理想选择。不同强度的红色可唤起激情、危险、冒险或诱惑等情感。Blackscreen.space 让您灵活运用红色传递品牌信息，在食品行业激发食欲，或在科技与工程领域展现热情与速度，吸引观众目光。\n提升视频通话的红屏魅力 在视频会议中，红屏能营造独特而深刻的氛围。结合红光散射与红色服饰，您可以传递温暖并留下难忘印象。Blackscreen.space 的红屏与环境光搭配，提升面部吸引力，为通话增添积极与乐观的气息。\n营造戏剧化氛围 无论是沉浸于悬疑小说，还是与朋友共创恐怖派对，红屏都能带来戏剧化的沉浸感。Blackscreen.space 的红屏替代刺眼灯光，增强环境氛围，让体验更具张力与吸引力。让红色为恐怖故事或游戏增添悬念与刺激。\n","permalink":"https://www.timestamps.top/zh/posts/red-screen/","summary":"欢迎访问 Blackscreen.space，这里以红色的动态与迷人魅力为核心。我们深知红色是一种引人注目的色彩，承载着丰富的含义与联想。Blackscreen.space 致力于打造以红屏为核心的多功能平台，从激发强烈情感与活力到优化视觉效果，为您的数字生活注入无限可能。 红屏的心理","title":"Red Screen"},{"content":"绿屏的舒缓与放松魅力 连接自然之美 绿色是大自然的象征，对我们的内心平静与纯净感有着深远影响。在融入绿色元素的环境中，人们往往感到更加放松与自在。公共场所、餐厅和酒店常通过设计、家具及植物引入绿色元素。借助 Blackscreen.space 的绿屏，您可以将自然的舒缓气息融入数字空间。\n减压与提升专注力 凝视绿色——无论是置身自然、浏览照片，还是使用鲜艳的绿屏——都能带来平静与放松的效果。绿色与宁静紧密相连，有助于缓解压力、增强自控力并提升专注度。通过绿屏的力量，打造一个宁静且高效的数字环境。\n绿屏的实用影响力 打造引人注目的广告牌 色彩在吸引客户与塑造品牌形象中至关重要。精心设计的绿屏广告牌能激发情感、抓住眼球并留下深刻印象。绿色传递共鸣、专业性与信任感，利用 Blackscreen.space 的绿屏工具，最大化您的广告视觉效果。\n提升影视与摄影效果 绿屏技术在电影制作与摄影领域广受欢迎。Blackscreen.space 的绿色背景便于后期移除并替换为多样化场景，为创作者提供无限灵活性。释放想象力，利用绿屏的多功能性，打造视觉惊艳的影片与照片。\n革新图像与视频内容 绿屏是内容创作的强大助力。通过 Blackscreen.space，您可以轻松替换背景、添加特效或调整色彩，塑造独特视觉风格。让绿屏的魔力为您的图像与视频注入魅力，为观众带来难忘体验。\n","permalink":"https://www.timestamps.top/zh/posts/green-screen/","summary":"绿屏的舒缓与放松魅力 连接自然之美 绿色是大自然的象征，对我们的内心平静与纯净感有着深远影响。在融入绿色元素的环境中，人们往往感到更加放松与自在。公共场所、餐厅和酒店常通过设计、家具及植物引入绿色元素。借助 Blackscreen.space 的绿屏，您可以将自然的舒缓气息融入数字空间。 减压与提升专注力 凝视绿色——无论","title":"Green Screen"},{"content":"欢迎访问 Blackscreen.space，这里以宁静与灵感为核心。我们相信蓝色能够唤起平静、稳定与高效的感受。\nBlue Screen的宁静与激励力量 宁静、安全与秩序 蓝屏让人联想到宁静与平和的情感。蓝色常与安静、安全及秩序感相联系，传递出可靠与稳定的气质。这种颜色不仅令人安心，还能激发信任与自信。\n提升生产力与专注力 研究显示，蓝色环境有助于提升生产力，是办公空间设计的优选色彩。蓝屏营造的平静氛围能帮助您保持专注，释放最佳潜能。利用 Blackscreen.space 的蓝屏功能，打造高效的工作与学习空间。\n蓝屏的实用场景 营造宁静与积极氛围 蓝屏唤起天空、海洋与黄昏的意象，带来宁静与积极的情感。通过 Blackscreen.space，您可以享受蓝屏带来的舒缓体验，为数字生活增添一抹平和与放松。\n高效复制与图像分层 Blackscreen.space 的蓝屏技术让图像复制与分层变得简单高效。无论是艺术创作还是教育用途，蓝屏都能支持精准编辑与呈现，助您展现卓越技能，令人叹为观止。\n优化视觉内容创作 无需高昂成本或远离工作场所，您也能打造引人注目的视觉内容。Blackscreen.space 的专业蓝屏背景能提升品牌形象，强化信息传递，帮助您在竞争中脱颖而出，创作独具特色的视频内容。\n蓝屏助力在线交流 呈现专业形象 在线会议中，以最佳状态展示自己至关重要。Blackscreen.space 的蓝屏背景提供柔和均匀的光线，营造视觉吸引力十足的环境，避免分散注意力的阴影，让您展现专业与从容的风采。\n","permalink":"https://www.timestamps.top/zh/posts/blue-screen/","summary":"欢迎访问 Blackscreen.space，这里以宁静与灵感为核心。我们相信蓝色能够唤起平静、稳定与高效的感受。 Blue Screen的宁静与激励力量 宁静、安全与秩序 蓝屏让人联想到宁静与平和的情感。蓝色常与安静、安全及秩序感相联系，传递出可靠与稳定的气质。这种颜色不仅令人安心，还能激发信","title":"Blue Screen"},{"content":"被工作追着跑，吃饭选择别再烧脑！“饭点儿”APP来救场\n身为上班族，每天忙碌于工作，本就神经紧绷。可一到中午、晚上这些饭点儿，又要被“吃什么”这个难题折磨。打开外卖软件，菜品繁多，刷来刷去，眼睛都花了，还是毫无头绪，宝贵的午休时间就这样在纠结中流逝。出去觅食吧，面对街边密密麻麻的店铺，选择困难症瞬间发作，饥肠辘辘却无从下手。这种纠结不定的感觉，是不是让你头疼不已？\n别担心，“饭点儿”APP就是你的救星，专为广大上班族量身打造，轻松解决吃饭选择难题。\n“饭点儿”最大的亮点，就是把选择的难题变成有趣的探索。无需在众多选项中苦苦挣扎，只需轻松摇一摇手机，一款附近的优质餐馆就会出现在你眼前。这种简单又充满趣味的交互方式，没有复杂的操作门槛，人人都能快速上手，让找餐馆变得像玩游戏一样轻松。\n每次摇一摇，都是一次新的惊喜。“饭点儿”会精准提供推荐餐馆的距离和具体位置，还有多角度的饭馆实景照片，让你还没到店，就能对餐馆有直观了解，提前感受用餐氛围。无论你是想找一家环境优雅的西餐厅犒劳自己，还是寻觅一家烟火气十足的小饭馆品尝家乡味道，“饭点儿”都能满足你。\n别再让吃饭选择成为负担，下载“饭点儿”APP ，让摇一摇开启美味新体验，从此告别饭点儿纠结，轻松享受每一餐！\n","permalink":"https://www.timestamps.top/zh/posts/fan-dian-er/","summary":"被工作追着跑，吃饭选择别再烧脑！“饭点儿”APP来救场 身为上班族，每天忙碌于工作，本就神经紧绷。可一到中午、晚上这些饭点儿，又要被“吃什么”这个难题折磨。打开外卖软件，菜品繁多，刷来刷去，眼睛都花了，还是毫无头绪，宝贵的午休时间就这样在纠结中流逝。出去觅食吧，面对街边密密麻麻的店","title":"饭点儿"},{"content":"欢迎访问 Blackscreen.space，这里以纯净而耀眼的白色为核心。我们深信，简洁与清晰是塑造卓越视觉体验的基础。\n白屏的力量 纯净清晰的视觉体验 Blackscreen.space 为您呈现白屏的极致美感。作为一块纯净的数字画布，它让您的图像与照片以惊艳的清晰度脱颖而出。无论是复制图片还是开启全新设计，White Screen都是追求精确与创意的理想选择，提升您的视觉呈现效果。\n优化的照明与平衡 通过 Blackscreen.space，您可以轻松获得理想的照明条件。无论是人像摄影还是专业工作室搭建，白屏作为可靠的光源，确保光线均匀柔和。其明亮的白色特性为您的创意项目增添光彩与深度，助力打造出色的视觉构图。\n白屏的实用价值 检测屏幕死点与优化触摸性能 白屏在排查屏幕问题时表现尤为出色，尤其适用于触摸设备。Blackscreen.space 的纯白背景能清晰揭示任何无响应区域，简化故障诊断与导航过程，帮助您快速提升设备的触摸体验与性能。\n多场景日常应用 白屏不仅限于摄影与数字界面，还能无缝融入日常生活。Blackscreen.space 可作为便携光源，为弱光环境下的阅读或物品查找提供便利；亦可化身化妆灯，带来聚焦照明以确保精准妆容。其明亮背景还能助力清洁，让污渍与异物一览无余。\n激发无限创意 以白屏为起点，释放您的创造力。Blackscreen.space 为动画艺术与故事叙述提供完美平台。只需白纸与笔等简单工具，您即可绘制引人入胜的插图与动画。借助白色的纯粹，将您的想象力转化为生动现实。\n","permalink":"https://www.timestamps.top/zh/posts/whitescreen/","summary":"欢迎访问 Blackscreen.space，这里以纯净而耀眼的白色为核心。我们深信，简洁与清晰是塑造卓越视觉体验的基础。 白屏的力量 纯净清晰的视觉体验 Blackscreen.space 为您呈现白屏的极致美感。作为一块纯净的数字画布，它让您的图像与照片以惊艳的清晰度脱颖而出。无论是复制图片还是开启全新设计，Whit","title":"White Screen"},{"content":"Blackscreen.space 是您探索黑色魅力的终极之选。我们坚信，简约与优雅是打造引人入胜视觉体验的核心所在。\nBlack Screen 的多功能性 无需关闭电源即可调节亮度 Black Screen 的核心功能之一在于，它能够在不完全关闭第二台显示器的情况下实现屏幕变暗。这一特性尤为适合需要在专注游戏或沉浸式电影体验中快速关闭辅助显示器的场景。Black Screen 让您轻松实现屏幕暗化，同时确保视觉沉浸感不受干扰。\n节能环保的明智选择 为响应可持续发展的号召，Blackscreen.space 通过启用黑色屏幕有效降低能耗并减少碳足迹。当您的计算机处于闲置状态时，选择黑屏模式不仅能节约能源，还能为环境保护贡献一份力量。通过简单而有意义的举措，我们携手为地球带来积极改变。\nBlack Screen 的多样化应用 隐秘您的 PC 活动 需要一种低调的方式隐藏计算机运行状态？Blackscreen.space 提供了一个优雅的解决方案。在多显示器环境中，当您希望屏幕保持开启而又不引人注意时，这一功能尤为实用。借助 Black Screen，您可以兼顾隐私保护与工作效率的优化。\n提升屏幕清洁效率 对于追求屏幕洁净的用户，Blackscreen.space 是一个实用的辅助工具。通过显示纯黑背景，即使是最细微的污渍或指纹也会一览无余，从而显著提升清洁效果。只需切换至 Black Screen 模式，您即可轻松确保显示器一尘不染，始终呈现最佳视觉效果。\n游戏与设计的理想搭档 对于游戏玩家和设计师而言，Blackscreen.space 是不可或缺的创作伙伴。其深邃的黑色背景能够增强对比度，将注意力集中于您的内容之上，让您完全沉浸于虚拟世界或设计作品中。您还可以自定义屏幕尺寸和边框颜色，使创作在优雅的黑色画布上绽放光彩。\nBlack Screen：全方位的解决方案 提升专注力与学习效率 在学习过程中保持专注往往充满挑战，尤其是在长时间面对明亮屏幕导致眼部疲劳时。Blackscreen.space 通过提供舒缓的视觉环境，帮助减少干扰并提升专注力。借助其宁静且放松的氛围，您可以更轻松地实现学习目标，优化学习体验。\n眼部舒适与视觉放松 在数字时代，我们的眼睛承受着前所未有的压力。Blackscreen.space 以其柔和的黑色调有效缓解眼部疲劳，为用户提供舒适的视觉体验。无论是长时间工作还是娱乐，Blackscreen.space 都能为您带来持久的视觉享受。\n操作方式 全屏 双击可以进入全屏模式，再双击退出全屏模式\n颜色切换 按鼠标方向键可以在 black screen, white screen, red screen, green screen, blue screen, yellow screen 之间循环切换\n","permalink":"https://www.timestamps.top/zh/posts/blackscreen/","summary":"Blackscreen.space 是您探索黑色魅力的终极之选。我们坚信，简约与优雅是打造引人入胜视觉体验的核心所在。 Black Screen 的多功能性 无需关闭电源即可调节亮度 Black Screen 的核心功能之一在于，它能够在不完全关闭第二台显示器的情况下实现屏幕变暗。这一特性尤为适合需要在专注游戏或沉浸式电影体验中快速关闭辅助显示器的场景。Blac","title":"Black Screen"},{"content":"git 仓库迁移，一般分为两种情况，从仓库 A 迁移到仓库 B 和从本地直接上传到仓库 B。\n从仓库 A 迁移到仓库 B 这种方式比较常见，也有很多 web 端直接支持镜像的方式，但批量的迁移还是要使用命令的，如下：\n$ git clone --bare http://a.com/crazykids.git $ git push --mirror http://b.com/crazykids.git 从本地直接上传到仓库 B 有的时候需要将本地仓库直接全部 push 到仓库 B，比如仓库 A 真的的挂了，或者你有多仓库备份的习惯。一般 push 命令只能将当前 branch 或者已经 checkout 出来的分支 push 的远端。\n增加仓库 B 地址 $ git remote add B http://b.com/crazykids.git 方式1 checkout 所有分支，再push到远端\n$ git fetch origin $ git branch -r | grep origin | grep -v HEAD|while read rb;do lb=$(echo ${rb}|cut -d/ -f 2-);git checkout -b $lb $rb;done $ git branch -r | grep origin | grep -v HEAD|while read rb;do lb=$(echo ${rb}|cut -d/ -f 2-);git push -f B $lb;done $ git push --tags 不但命令麻烦，如果遇到分支差异比较大的，还经常出现问题。\n方式2 $ git fetch origin $ git push B \u0026#39;refs/remotes/origin/*\u0026#39;:\u0026#39;refs/heads/*\u0026#39; \u0026#39;refs/tags/*\u0026#39;:\u0026#39;refs/tags/*\u0026#39; ","permalink":"https://www.timestamps.top/zh/posts/git-mirgration/","summary":"git 仓库迁移，一般分为两种情况，从仓库 A 迁移到仓库 B 和从本地直接上传到仓库 B。 从仓库 A 迁移到仓库 B 这种方式比较常见，也有很多 web 端直接支持镜像的方式，但批量的迁移还是要使用命令的，如下： $ git clone --bare http://a.com/crazykids.git $ git push --mirror http://b.com/crazykids.git 从本地直接上传到仓库 B 有的时候需要将本地仓库直接全部 push 到仓库 B，比如仓库 A 真的","title":"Git 仓库迁移"},{"content":"查看所有分支 $ git branch -a 查看远程分支 $ git branch -r 查看本地分支所关联的远程分支 $ git branch -vv 重命名本地分支 $ git branch -m old_branch new_branch 删除远程分支 $ git branch -d -r origin/old_branch $ git push origin :old_branch 推送新的分支 $ git push -u origin new_branch 设置关联 $ git branch --set-upstream-to=origin/branch branch ","permalink":"https://www.timestamps.top/zh/posts/git_branch/","summary":"查看所有分支 $ git branch -a 查看远程分支 $ git branch -r 查看本地分支所关联的远程分支 $ git branch -vv 重命名本地分支 $ git branch -m old_branch new_branch 删除远程分支 $ git branch -d -r origin/old_branch $ git push origin :old_branch 推送新的分支 $ git push -u origin new_branch 设置关联 $ git branch --set-upstream-to=origin/branch branch","title":"git 分支操作常用命令"},{"content":"00 安装Hugo 到 Hugo Releases 下载对应的操作系统版本的 Hugo 二进制文件\nMac 下可以直接使用 Homebrew 安装：\n$ brew install hugo 01 生成站点 使用 Hugo 快速生成站点\n$ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进入目录：\n$ cd /path/to/site 02 安装主题 到 主题列表 挑选主题，找到相关的 GitHub 地址，创建目录 themes, 把主题 clone 下来\n$ git clone https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 在配置文件中设置主题名字\ntheme: PaperMod 03 配置文件 Hugo 默认使用的 toml 格式的配置文件，也支持 yaml 格式。 详细说明可以参考 Hugo的官方文档\n示例配置 config.yaml 如下\nbaseURL: \u0026#39;https://blog.crazykids.tech/\u0026#39; theme: \u0026#39;PaperMod\u0026#39; languageCode: \u0026#39;zh-cn\u0026#39; languageName: \u0026#39;简体中文\u0026#39; hasCJKLanguage: true title: \u0026#39;TimeStamps\u0026#39; paginate: 15 summaryLength: 120 # 文章概览的自字数，默认70 author: name: \u0026#39;duanhongjin\u0026#39; email: \u0026#39;duanhjlt@163.com\u0026#39; link: \u0026#39;https://blog.crazykids.tech/\u0026#39; enableInlineShortcodes: true enableEmoji: true enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true # minifyOutput: true menu: main: - weight: 1 identifier: \u0026#39;post\u0026#39; name: \u0026#39;文章\u0026#39; url: \u0026#39;/\u0026#39; - weight: 2 identifier: \u0026#39;tags\u0026#39; name: \u0026#39;标签\u0026#39; url: \u0026#39;/tags/\u0026#39; - weight: 3 identifier: \u0026#39;categories\u0026#39; name: \u0026#39;分类\u0026#39; url: \u0026#39;/categories/\u0026#39; - weight: 4 identifier: \u0026#39;about\u0026#39; name: \u0026#39;关于\u0026#39; url: \u0026#39;/about/\u0026#39; outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. author: duanhongjin defaultTheme: auto # defaultTheme: light or dark disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; ShowShareButtons: true ShowReadingTime: true # disableSpecialistPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # 隐藏页脚 ShowWordCounts: true VisitCount: true ShowLastMod: true #显示文章更新时间 ShowToc: true # 显示目录 TocOpen: true # 自动展开目录 extendCodeBackground: false # 代码块是否自动横向展开 comments: true socialIcons: - name: github url: \u0026#34;https://github.com/duanhjlt\u0026#34; - name: RSS url: \u0026#34;index.xml\u0026#34; cover: hidden: false # hide everywhere but not in structured data hiddenInList: false # hide on list pages and home hiddenInSingle: false # hide on single page editPost: URL: \u0026#34;https://github.com/duanhjlt/blog/tree/main/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link markup: highlight: noClasses: false 04 启动博客 $ hugo server -D 本地预览，本地预览网址为 http://localhost:1313\n$ hugo -F --cleanDestinationDir 生成全新的 public 文件夹，这个文件夹可以部署到云服务器上\n05 写文章 $ hugo new new-post.md hugo 会在 content 目录下生成\u0026quot;new-post.md\u0026quot;名字的文件，所有的文章都会放到 content 目录下\n如何自己定义的子目录，如 posts，可以使用命令\n$ hugo new posts/new-post.md 06 文章默认配置 生成文章内部文件头部配置信息包括一些文章名称，时间之类的信息，可以写到 archetypes/default.md 中做为模版，这样生成文章时会自动添加模版里的配置\n示例配置如下:\n--- keywords: [] title: \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; date: {{ .Date }} lastmod: {{ .Date }} draft: false description: author: \u0026#39;duanhongjin\u0026#39; tags: [] categories: [] tocLevels: [\u0026#34;h2\u0026#34;, \u0026#34;h3\u0026#34;, \u0026#34;h4\u0026#34;] comments: true # 本页面是否显示评论 reward: true # 打赏 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示路径 --- 07 部署到GitHub Pages 在 GitHub 上创建仓库，名字可以是 duanhjlt.github.io，也可以是其他的，在 GitHub Pages 进行设置即可\n如果想使用自己的域名，如本站域名 blog.crazykids.tech，可以\n在 dns 增加 blog 到 duanhjlt.gihub.io. 的 CNAME 配置项 在 GitHub 的仓库中增加 CNAME 文件，内容为 blog.crazykids.tech 将 public 文件夹做为 GitHub Pages 的本地仓库，每次生成后，推送到 GitHub 上，GitHub Pages 就会自动部署了\n","permalink":"https://www.timestamps.top/zh/posts/hugo-site/","summary":"00 安装Hugo 到 Hugo Releases 下载对应的操作系统版本的 Hugo 二进制文件 Mac 下可以直接使用 Homebrew 安装： $ brew install hugo 01 生成站点 使用 Hugo 快速生成站点 $ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进入目录： $ cd /path/to/site 02 安装主题 到 主题列表 挑选主题，找到相关的 GitHub 地址，创建目录 themes, 把主题 clone 下来 $ git clone https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 在配置文件中设置主题名字 theme:","title":"Hugo + Github Pages 建站"},{"content":"中年 iOS/macos 开发\nMemora：专为iOS和macOS设计的离线稍后读应用: Memora是一款安全可靠的稍后读应用，支持网页离线保存、iCloud同步和无干扰阅读体验。通过标签分类和智能搜索，轻松管理你的阅读清单。 Black Screen: 黑色力量的终极目的地, 简约和优雅是迷人视觉体验的核心。 xvm: [node|golang|python] 版本管理 xvm-windows: [node|golang|python] 版本管理 饭点儿: 到饭点儿，轻轻一摇推荐附近的餐馆 It is friday?: Check if it is friday? 联系方式 E-mail: duanhjlt@gmail.com Github: duan0120 X: @duanhjlt Telegram: @duanhjlt ","permalink":"https://www.timestamps.top/zh/about/","summary":"中年 iOS/macos 开发 Memora：专为iOS和macOS设计的离线稍后读应用: Memora是一款安全可靠的稍后读应用，支持网页离线保存、iCloud同步和无干扰阅读体验。通过标签分类和智能搜索，轻松管理你的阅读清单。 Black Screen: 黑色力量的终极目的地, 简约和优雅是迷人视觉体验的核心。 xvm: [node|golang|python] 版本管理 xvm-windows: [node|golang|python]","title":"简介"},{"content":"1. 引言 欢迎访问 TimeStamps（以下简称”本网站”）。我们重视您的隐私，并致力于保护您的个人信息。本隐私政策旨在说明我们如何收集、使用和保护您的信息。\n2. 信息收集 2.1 自动收集的信息 我们可能会自动收集以下信息：\n访问日志（IP地址、浏览器类型、访问时间）\n设备信息（操作系统、设备类型）\n浏览行为（访问页面、停留时间） ###2.2 Cookie 使用 本网站使用 Cookie 和类似技术来：\n记住您的偏好设置\n分析网站流量\n改善用户体验\n3. 信息使用 我们收集的信息将用于：\n提供和改进网站服务 分析网站使用情况 优化网站内容和用户体验 防止欺诈和滥用 4. 信息共享 我们不会出售、出租或以其他方式分享您的个人信息，除非：\n获得您的明确同意 法律要求 保护网站及用户权益 5. 第三方服务 本网站使用以下第三方服务：\nGoogle Analytics（网站分析） Google AdSense（广告服务） 这些服务可能收集您的信息，建议您查看它们各自的隐私政策。 6. 数据安全 我们采取适当的技术和组织措施来保护您的信息，防止未经授权的访问、使用或泄露。\n7. 您的权利 您有权：\n访问您的个人信息 更正不准确的信息 要求删除您的信息 反对或限制信息处理 撤回同意 儿童隐私 本网站不面向13岁以下儿童，我们不会故意收集儿童的个人信息。\n隐私政策更新 我们可能会不时更新本隐私政策。更新后的政策将在本页面上发布，并注明最后更新日期。\n联系我们 如果您对本隐私政策有任何问题或建议，请通过以下方式联系我们：\n电子邮件：duanhjlt@gmail.com 适用法律 本隐私政策受中华人民共和国法律管辖。 ","permalink":"https://www.timestamps.top/zh/privacy/","summary":"1. 引言 欢迎访问 TimeStamps（以下简称”本网站”）。我们重视您的隐私，并致力于保护您的个人信息。本隐私政策旨在说明我们如何收集、使用和保护您的信息。 2. 信息收集 2.1 自动收集的信息 我们可能会自动收集以下信息： 访问日志（IP地址、浏览器类型、访问时间） 设备信息（操作系统、设备类型）","title":"隐私政策"}]